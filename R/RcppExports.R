# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Test subsetting X[ind,] funktioniert!!!
#' @noRd
subset_X <- function(X, ind) {
    .Call(`_phangorn_subset_X`, X, ind)
}

contr_P_ind <- function(contr, P, ind) {
    .Call(`_phangorn_contr_P_ind`, contr, P, ind)
}

getP_arma <- function(e_value, e_vec, e_vec_inv, el, g) {
    .Call(`_phangorn_getP_arma`, e_value, e_vec, e_vec_inv, el, g)
}

rowMinScale_arma <- function(dat, k) {
    .Call(`_phangorn_rowMinScale_arma`, dat, k)
}

lll <- function(X, Y, SC, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf) {
    .Call(`_phangorn_lll`, X, Y, SC, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf)
}

lll_E <- function(X, Y, SC, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf, SCM) {
    .Call(`_phangorn_lll_E`, X, Y, SC, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf, SCM)
}

PML_E <- function(X, Y, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf, SCM, nNodes) {
    .Call(`_phangorn_PML_E`, X, Y, e_value, e_vec, e_vec_inv, contrast, el, node, edge, g, w, nTips, bf, SCM, nNodes)
}

NR_f_arma <- function(eva, el, w, g, X, k) {
    .Call(`_phangorn_NR_f_arma`, eva, el, w, g, X, k)
}

NR_df_arma <- function(eva, el, w, g, X, k, f) {
    .Call(`_phangorn_NR_df_arma`, eva, el, w, g, X, k, f)
}

NR_d2f_arma <- function(eva, el, w, g, X, k, f) {
    .Call(`_phangorn_NR_d2f_arma`, eva, el, w, g, X, k, f)
}

fs_3 <- function(eva, el, w, g, X, ld, weight, f0, tau) {
    .Call(`_phangorn_fs_3`, eva, el, w, g, X, ld, weight, f0, tau)
}

readPML <- function(xlist, nSeq, m) {
    .Call(`_phangorn_readPML`, xlist, nSeq, m)
}

fhm_new <- function(v, n) {
    .Call(`_phangorn_fhm_new`, v, n)
}

allDescCPP <- function(orig, nTips) {
    .Call(`_phangorn_allDescCPP`, orig, nTips)
}

countCycle_cpp <- function(M) {
    .Call(`_phangorn_countCycle_cpp`, M)
}

countCycle2_cpp <- function(M) {
    .Call(`_phangorn_countCycle2_cpp`, M)
}

out_cpp <- function(d, r, n) {
    .Call(`_phangorn_out_cpp`, d, r, n)
}

getIndex <- function(left, right, n) {
    .Call(`_phangorn_getIndex`, left, right, n)
}

Transfer_Index <- function(bp, orig, l) {
    .Call(`_phangorn_Transfer_Index`, bp, orig, l)
}

bipartCPP <- function(orig, nTips) {
    .Call(`_phangorn_bipartCPP`, orig, nTips)
}

sorted_bipartCPP <- function(orig, nTips) {
    .Call(`_phangorn_sorted_bipartCPP`, orig, nTips)
}

short_bipCPP <- function(orig, nTips) {
    .Call(`_phangorn_short_bipCPP`, orig, nTips)
}

bipCPP <- function(orig, nTips) {
    .Call(`_phangorn_bipCPP`, orig, nTips)
}

allChildrenCPP <- function(orig) {
    .Call(`_phangorn_allChildrenCPP`, orig)
}

allSiblingsCPP <- function(edge) {
    .Call(`_phangorn_allSiblingsCPP`, edge)
}

p2dna <- function(xx, eps = 0.999) {
    .Call(`_phangorn_p2dna`, xx, eps)
}

node_height_cpp <- function(edge1, edge2, edge_length) {
    .Call(`_phangorn_node_height_cpp`, edge1, edge2, edge_length)
}

cophenetic_cpp <- function(edge, edge_length, nTips, nNode) {
    .Call(`_phangorn_cophenetic_cpp`, edge, edge_length, nTips, nNode)
}

#' @rdname phangorn-internal
#' @export
threshStateC <- function(x, thresholds) {
    .Call(`_phangorn_threshStateC`, x, thresholds)
}

