[{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Advanced features","text":"document illustrates phangorn (Schliep 2011) specialized features useful maybe well-known just (yet) described elsewhere. mainly interesting someone wants explore different models set simulation studies. show construct data objects different character states nucleotides amino acids set different models estimate transition rate. vignette Trees describes detail estimate phylogenies nucleotide amino acids.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"user-defined-data-formats","dir":"Articles","previous_headings":"","what":"User defined data formats","title":"Advanced features","text":"better understand define data type useful know bit internal representation phyDat objects. internal representation phyDat object similar factor objects. example show several possibilities define nucleotide data gaps defined fifth state. Ignoring gaps coding ambiguous sites - done programs, also phangorn default - may misleading (see (Warnow 2012)). number gaps low gaps missing random coding gaps separate state may important. Let assume given matrix row contains character vector taxonomic unit: Normally transform matrix phyDat object gaps handled ambiguous character like “?”. Now define “USER” defined object supply vector levels character states new data, case nucleotide states gap. Additional can define ambiguous states can states. yet wanted two sites alignment, contain ambiguous characters “r” “y”, got deleted. define ambiguous characters like “r” “y” explicitly supply contrast matrix similar contrasts factors. defined “n” state can nucleotide gap “-” “?” can state including gap. data can used functions available phangorn compute distance matrices perform parsimony maximum likelihood analysis.","code":"library(phangorn) ## Loading required package: ape data = matrix(c(\"r\",\"a\",\"y\",\"g\",\"g\",\"a\",\"c\",\"-\",\"c\",\"t\",\"c\",\"g\",     \"a\",\"a\",\"t\",\"g\",\"g\",\"a\",\"t\",\"-\",\"c\",\"t\",\"c\",\"a\",     \"a\",\"a\",\"t\",\"-\",\"g\",\"a\",\"c\",\"c\",\"c\",\"t\",\"?\",\"g\"),     dimnames = list(c(\"t1\", \"t2\", \"t3\"),NULL), nrow=3, byrow=TRUE) data ##    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] ## t1 \"r\"  \"a\"  \"y\"  \"g\"  \"g\"  \"a\"  \"c\"  \"-\"  \"c\"  \"t\"   \"c\"   \"g\"   ## t2 \"a\"  \"a\"  \"t\"  \"g\"  \"g\"  \"a\"  \"t\"  \"-\"  \"c\"  \"t\"   \"c\"   \"a\"   ## t3 \"a\"  \"a\"  \"t\"  \"-\"  \"g\"  \"a\"  \"c\"  \"c\"  \"c\"  \"t\"   \"?\"   \"g\" gapsdata1 = phyDat(data) gapsdata1 ## 3 sequences with 12 character and 11 different site patterns. ## The states are a c g t gapsdata2 = phyDat(data, type=\"USER\", levels=c(\"a\",\"c\",\"g\",\"t\",\"-\"),     ambiguity = c(\"?\", \"n\")) ## Warning in phyDat.default(data, levels = levels, return.index = return.index, : ## Found unknown characters (not supplied in levels). Deleted sites with unknown ## states. gapsdata2 ## 3 sequences with 10 character and 9 different site patterns. ## The states are a c g t - contrast = matrix(data = c(1,0,0,0,0,     0,1,0,0,0,     0,0,1,0,0,     0,0,0,1,0,     1,0,1,0,0,     0,1,0,1,0,     0,0,0,0,1,     1,1,1,1,0,     1,1,1,1,1),     ncol = 5, byrow = TRUE) dimnames(contrast) = list(c(\"a\",\"c\",\"g\",\"t\",\"r\",\"y\",\"-\",\"n\",\"?\"),     c(\"a\", \"c\", \"g\", \"t\", \"-\")) contrast ##   a c g t - ## a 1 0 0 0 0 ## c 0 1 0 0 0 ## g 0 0 1 0 0 ## t 0 0 0 1 0 ## r 1 0 1 0 0 ## y 0 1 0 1 0 ## - 0 0 0 0 1 ## n 1 1 1 1 0 ## ? 1 1 1 1 1 gapsdata3 = phyDat(data, type=\"USER\", contrast=contrast) gapsdata3 ## 3 sequences with 12 character and 11 different site patterns. ## The states are a c g t -"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"markov-models-of-character-evolution","dir":"Articles","previous_headings":"","what":"Markov models of character evolution","title":"Advanced features","text":"model nucleotide substitutions across edges tree T can assign transition matrix. case nucleotides, four character states, 4 \\(\\times\\) 4 transition matrix , , 12 free parameters. Time-reversible Markov models used describe characters change time, use fewer parameters. Time-reversible means models need directed time, Markov property states models depend current state. models used analysis phylogenies using maximum likelihood MCMC, computing pairwise distances, well simulating sequence evolution. now describe General Time-Reversible (GTR) model (Tavaré 1986). parameters GTR model equilibrium frequencies \\(\\pi = (\\pi_A ,\\pi_C ,\\pi_G ,\\pi_T)\\) rate matrix \\(Q\\) form \\[\\begin{equation} Q = \\begin{pmatrix} \\ast  & \\alpha\\pi_C & \\beta\\pi_G & \\gamma\\pi_T \\\\ \\alpha\\pi_A & \\ast & \\delta\\pi_G & \\epsilon\\pi_T \\\\ \\beta\\pi_A & \\delta\\pi_C & \\ast & \\eta\\pi_T \\\\ \\gamma\\pi_A &  \\epsilon\\pi_C & \\eta\\pi_G & \\ast \\\\ \\end{pmatrix} (1) \\end{equation}\\] need assign 6 parameters \\(\\alpha, \\dots, \\eta\\). elements diagonal chosen rows sum zero. Jukes-Cantor (JC) (Jukes Cantor 1969) model can derived special case GTR model, equal equilibrium frequencies \\(\\pi_A = \\pi_C = \\pi_G = \\pi_T = 0.25\\) equal rates set \\(\\alpha = \\beta = \\gamma = \\delta = \\eta\\). Table @ref(tab:models) lists built-nucleotide models phangorn. transition probabilities describe probabilities change character \\(\\) \\(j\\) time \\(t\\), given corresponding entries matrix exponential \\[ P(t) = (p_{ij}(t)) = e^{Qt}, \\qquad \\sum_j p_{ij}=1 \\] \\(P(t)\\) transition matrix spanning period time \\(t\\).","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"estimation-of-non-standard-transition-rate-matrices","dir":"Articles","previous_headings":"","what":"Estimation of non-standard transition rate matrices","title":"Advanced features","text":"last section @ref(user) described set user defined data formats. Now describe estimate transition matrices pml. nucleotide data common models can called directly optim.pml function (e.g. “JC69”, “HKY”, “GTR” name ). Table 2 lists available nucleotide models, can estimated directly optim.pml. amino acids several transition matrices available (“WAG”, “JTT”, “LG”, “Dayhoff”, “cpREV”, “mtmam”, “mtArt”, “MtZoa”, “mtREV24”, “VT”,“RtREV”, “HIVw”, “HIVb”, “FLU”, “Blosum62”, “Dayhoff_DCMut” “JTT-DCMut”) can estimated optim.pml. example Mathews et al. (2010) (Mathews, Clements, Beilstein 2010) used function estimate phytochrome amino acid transition matrix. now show estimate rate matrix different transition (\\(\\alpha\\)) transversion ratio (\\(\\beta\\)) fixed rate gap state (\\(\\gamma\\)) - kind Kimura two-parameter model (K81) nucleotide data gaps fifth state (see table 1). Tab 1. Rate matrix 3 parameters optimize. want fit non-standard transition rate matrices, tell optim.pml, transitions Q get rate. parameter vector subs accepts vector consecutive integers least one element zero (gets reference rate 1). Negative values indicate direct transition possible rate set zero. conventions models estimated: model supplied base frequencies bf rate matrix Q optimized according model (nucleotides) adequate rate matrix frequencies chosen (amino acids). optQ=TRUE neither model subs supplied symmetric (optBf=FALSE) reversible model (optBf=TRUE, .e. GTR nucleotides) estimated. can slow many character states, e.g. amino acids. Table 2 shows parameters optimized number parameters estimate. elements vector subs correspond \\(\\alpha, \\dots, \\eta\\) equation (1) Tab 2. DNA models available phangorn.","code":"library(ape) tree <- unroot(rtree(3)) fit <- pml(tree, gapsdata3) fit <- optim.pml(fit, optQ=TRUE, subs=c(1,0,1,2,1,0,2,1,2,2),     control=pml.control(trace=0)) fit ## model: Mk  ## loglikelihood: -33.01  ## unconstrained loglikelihood: -28.43  ##  ## Rate matrix: ##           a         c         g         t      - ## a 0.000e+00 2.584e-06 1.000e+00 2.584e-06 0.6912 ## c 2.584e-06 0.000e+00 2.584e-06 1.000e+00 0.6912 ## g 1.000e+00 2.584e-06 0.000e+00 2.584e-06 0.6912 ## t 2.584e-06 1.000e+00 2.584e-06 0.000e+00 0.6912 ## - 6.912e-01 6.912e-01 6.912e-01 6.912e-01 0.0000 ##  ## Base frequencies:   ##   a   c   g   t   -  ## 0.2 0.2 0.2 0.2 0.2"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"codon-substitution-models","dir":"Articles","previous_headings":"","what":"Codon substitution models","title":"Advanced features","text":"special case transition rates codon models._phangorn_ now offers possibility estimate \\(d_N/d_S\\) ratio (sometimes called ka/ks), overview see (Yang 2014). functions extend option estimates \\(d_N/d_S\\) ratio pairwise sequence comparison available function kaks seqinr. transition rate codon \\(\\) \\(j\\) defined follows: \\[\\begin{eqnarray} q_{ij}=\\left\\{     \\begin{array}{l@{\\quad}l}          0 & \\textrm{j differ one position} \\\\          \\pi_j & \\textrm{synonymous transversion} \\\\          \\pi_j\\kappa & \\textrm{synonymous transition} \\\\          \\pi_j\\omega & \\textrm{non-synonymous transversion} \\\\          \\pi_j\\omega\\kappa & \\textrm{non synonymous transition}     \\end{array}     \\right. \\nonumber \\end{eqnarray}\\] \\(\\omega\\) \\(d_N/d_S\\) ratio, \\(\\kappa\\) transition transversion ratio \\(\\pi_j\\) equilibrium frequencies codon \\(j\\). \\(\\omega\\sim1\\) amino acid change neutral, \\(\\omega < 1\\) purifying selection \\(\\omega > 1\\) positive selection. four models available: “codon0”, parameter \\(\\kappa\\) \\(\\omega\\) fixed 1, “codon1” parameters estimated “codon2” “codon3” \\(\\kappa\\) \\(\\omega\\) fixed 1. compute \\(d_N/d_S\\) sequences given tree using ML functions pml optim.pml. First transform nucleotide sequences codons (far algorithms always takes triplets). several ways estimate codon frequencies \\(\\pi_j\\). simplest model assume equal frequencies (=1/61). second use empirical codon frequencies, either computed using baseFreq using argument bf=\"empirical\" pml. Last least frequencies can derived base frequencies codon position, F3x4 model set argument bf=\"F3x4\". One can estimate codon frequencies setting option optBf=TRUE optim.pml. convergence 60 parameters convergence likely slow set maximal iterations higher value default (e.g. control = pml.control(maxit=50)). Similar parameters F3x4 can also estimated using ML optF3x4=TRUE instead. “YN98” model (Yang Nielsen 1998) similar “codon1”, additional optimizes codon frequencies.","code":"library(phangorn) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\") tree <- NJ(dist.ml(primates)) dat <- dna2codon(primates) fit <- pml(tree, dat, bf=\"F3x4\") fit0 <- optim.pml(fit, model=\"codon0\", control=pml.control(trace=0)) fit1 <- optim.pml(fit, model=\"codon1\", control=pml.control(trace=0)) fit2 <- optim.pml(fit, model=\"codon2\", control=pml.control(trace=0)) fit3 <- optim.pml(fit, model=\"codon3\", control=pml.control(trace=0)) anova(fit0, fit2, fit3, fit1) ## Likelihood Ratio Test Table ##   Log lik. Df Df change Diff log lik. Pr(>|Chi|)     ## 1    -2867 34                                        ## 2    -2866 35         1             2       0.14     ## 3    -2522 35         0           688     <2e-16 *** ## 4    -2521 36         1             2       0.20     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"generating-trees","dir":"Articles","previous_headings":"","what":"Generating trees","title":"Advanced features","text":"phangorn several functions generate tree topologies, may interesting simulation studies. allTrees computes possible bifurcating tree topologies either rooted unrooted 10 taxa. One keep mind number trees growing exponentially, use howmanytrees ape reminder.  nni returns list trees one nearest neighbor interchange away. rNNI rSPR generate trees defined number NNI (nearest neighbor interchange) SPR (subtree pruning regrafting) away.","code":"trees <- allTrees(5) par(mfrow=c(3,5), mar=rep(0,4)) for(i in 1:15)plot(trees[[i]], cex=1, type=\"u\") nni(trees[[1]]) ## 4 phylogenetic trees"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Advanced features","text":"","code":"## R version 4.2.1 (2022-06-23) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.9.0.9000 ape_5.6-2           ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.9        highr_0.9         bslib_0.4.0       compiler_4.2.1    ##  [5] jquerylib_0.1.4   prettydoc_0.4.1   tools_4.2.1       digest_0.6.29     ##  [9] jsonlite_1.8.0    evaluate_0.15     memoise_2.0.1     nlme_3.1-157      ## [13] lattice_0.20-45   pkgconfig_2.0.3   rlang_1.0.4       Matrix_1.4-1      ## [17] fastmatch_1.1-3   igraph_1.3.4      cli_3.3.0         yaml_2.3.5        ## [21] parallel_4.2.1    pkgdown_2.0.6     xfun_0.31         fastmap_1.1.0     ## [25] stringr_1.4.0     knitr_1.39        desc_1.4.1        generics_0.1.3    ## [29] fs_1.5.2          sass_0.4.2        systemfonts_1.0.4 rprojroot_2.0.3   ## [33] grid_4.2.1        R6_2.5.1          textshaping_0.3.6 rmarkdown_2.14    ## [37] purrr_0.3.4       magrittr_2.0.3    codetools_0.2-18  htmltools_0.5.3   ## [41] quadprog_1.5-8    ragg_1.2.2        stringi_1.7.8     cachem_1.0.6"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ancestral Sequence Reconstruction","text":"notes describe ancestral sequence reconstruction using phangorn package (Schliep 2011). phangorn provides several methods estimate ancestral character states either Maximum Parsimony (MP) Maximum Likelihood (ML). background methods see e.g. (Felsenstein 2004) (Yang 2006).","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"parsimony-reconstructions","dir":"Articles","previous_headings":"","what":"Parsimony reconstructions","title":"Ancestral Sequence Reconstruction","text":"reconstruct ancestral sequences first load data reconstruct tree: parsimony analysis edge length represent observed number changes. Reconstructing ancestral states therefore defines also edge lengths tree. However can exist several equally parsimonious reconstructions states can ambiguous therefore edge length can differ. “MPR” reconstructs ancestral states (internal) node tree rooted node. However nodes independent . one chooses one state specific node, can restrict choice neighboring nodes (figures 2 3). function acctran (accelerated transformation) assigns edge length internal nodes tree (Swofford Maddison 1987). ancestral reconstructions parsimony based fitch algorithm far bifurcating trees allowed. However trees can get pruned afterwards using function multi2di ape. seqLogo function seqLogo package Bioconductor provides neat way show proportions nucleotides ancestral states (see figure 1).  may need install seqLogo Fig 2. Ancestral reconstruction using MPR. Fig 3. Ancestral reconstruction using ACCTRAN.","code":"library(phangorn) ## Loading required package: ape fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\") tree <- pratchet(primates, trace=0) |> acctran(primates) parsimony(tree, primates) ## [1] 746 anc.acctran <- ancestral.pars(tree, primates, \"ACCTRAN\") anc.mpr <- ancestral.pars(tree, primates, \"MPR\") library(seqLogo) seqLogo( t(subset(anc.mpr, getRoot(tree), 1:20)[[1]]), ic.scale=FALSE) if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(\"seqLogo\") plotAnc(tree, anc.mpr, 17) title(\"MPR\") plotAnc(tree, anc.acctran, 17) title(\"ACCTRAN\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"likelihood-reconstructions","dir":"Articles","previous_headings":"","what":"Likelihood reconstructions","title":"Ancestral Sequence Reconstruction","text":"phangorn also offers possibility estimate ancestral states using ML. advantages ML parsimony reconstruction accounts different edge lengths. far marginal construction implemented (see (Yang 2006)). can assign ancestral states according highest likelihood (“ml”): \\[ P(x_r = ) =  \\frac{L(x_r=)}{\\sum_{k \\\\{,C,G,T\\}}L(x_r=k)} \\] highest posterior probability (“bayes”) criterion: \\[ P(x_r=) =  \\frac{\\pi_A L(x_r=)}{\\sum_{k \\\\{,C,G,T\\}}\\pi_k L(x_r=k)}, \\] \\(L(x_r)\\) joint probability states tips state root \\(x_r\\) \\(\\pi_i\\) estimated base frequencies state \\(\\). methods agree states (base frequencies) equal probabilities. differences two approaches specific site (17) represented following figures. Fig 4. Ancestral reconstruction using maximum likelihood. Fig 5. Ancestral reconstruction using (empirical) Bayes.","code":"fit <- pml(tree, primates) fit <- optim.pml(fit, model=\"F81\", control = pml.control(trace=0)) anc.ml <- ancestral.pml(fit, \"ml\") anc.bayes <- ancestral.pml(fit, \"bayes\") plotAnc(tree, anc.ml, 17) title(\"ML\") plotAnc(tree, anc.bayes, 17) title(\"Bayes\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Ancestral Sequence Reconstruction","text":"","code":"## R version 4.2.1 (2022-06-23) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.9.0.9000 ape_5.6-2           ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.9        highr_0.9         bslib_0.4.0       compiler_4.2.1    ##  [5] jquerylib_0.1.4   prettydoc_0.4.1   tools_4.2.1       digest_0.6.29     ##  [9] jsonlite_1.8.0    evaluate_0.15     memoise_2.0.1     nlme_3.1-157      ## [13] lattice_0.20-45   pkgconfig_2.0.3   rlang_1.0.4       Matrix_1.4-1      ## [17] fastmatch_1.1-3   igraph_1.3.4      cli_3.3.0         yaml_2.3.5        ## [21] parallel_4.2.1    pkgdown_2.0.6     xfun_0.31         fastmap_1.1.0     ## [25] stringr_1.4.0     knitr_1.39        desc_1.4.1        generics_0.1.3    ## [29] fs_1.5.2          sass_0.4.2        systemfonts_1.0.4 rprojroot_2.0.3   ## [33] grid_4.2.1        R6_2.5.1          textshaping_0.3.6 rmarkdown_2.14    ## [37] purrr_0.3.4       magrittr_2.0.3    codetools_0.2-18  htmltools_0.5.3   ## [41] quadprog_1.5-8    ragg_1.2.2        stringi_1.7.8     cachem_1.0.6"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"installing-r","dir":"Articles","previous_headings":"","what":"Installing R","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Download R Select nearest mirror location https://cran.r-project.org/mirrors.html Select operating system download relevant installation file. Install R following instructions.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"installing-the-phangorn-library","dir":"Articles","previous_headings":"","what":"Installing the phangorn library","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Open R run two lines code command line. (need select region download library)","code":"install.packages(\"phangorn\", dependencies=TRUE) # install latest development version needs devtools install.packages(\"devtools\", dependencies=TRUE) library(devtools) install_github(\"KlausVigo/phangorn\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"","code":"library(phangorn)    # load the phangorn library ## Loading required package: ape"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"set-the-working-directory","dir":"Articles","previous_headings":"","what":"Set the working directory","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"often major stumbling block new R users. need specify folder structure wish work. .e, files stored wish input? done using setwd() function, e.g. setwd(\"C:/TreesNetworks/Example Files\"). now set folder phangorn package, contains files want load example.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"read-in-the-example-file-datasets","dir":"Articles","previous_headings":"","what":"Read in the example file datasets:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"example files based woodmouse dataset available ape library. Ultimately, dataset study: Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. Libois, R. (2003) Mitochondrial phylogeography Woodmouse (Apodemus sylvaticus) Western Palearctic region. Molecular Ecology, 12, 685-697.) example files read R.","code":"## automatically set the correct working directory for the examples below # setwd(system.file(\"extdata/trees\", package = \"phangorn\")) # for this vignette we create a path to the files we want to load  fdir <- system.file(\"extdata/trees\", package = \"phangorn\") ## in your case it may look something like this... # setwd(\"C:/TreesNetworks/Example Files\")  ##DNA Matrix, maybe not needed  woodmouse <- read.phyDat(file.path(fdir, \"woodmouse.fasta\"),format=\"fasta\")  ## RAxML best-known tree with bipartition support (from previous analysis) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bipartitions.woodmouse\")) ## RAxML bootstrap trees (from previous analysis) raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.woodmouse\")) ## MrBayes consensus tree (50% majority rule) (from previous analysis) mrbayes.tree <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.con\")) ## MrBayes sample runs 1 and 2 (from previous analysis) run1 <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.run1.t\")) run2 <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.run2.t\")) ## How many trees are in the MrBayes tree sample? run1 ## 1001 phylogenetic trees run2 ## 1001 phylogenetic trees ## Combining the two runs and removing 25% burn-in mrbayes.trees <- c(run1[251:1001],run2[251:1001]) ## NeigbourNet Nexus file generated by SplitsTree (from previous analysis) Nnet <- read.nexus.networx(file.path(fdir,\"woodmouse.nxs\"))"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"viewing-the-data","dir":"Articles","previous_headings":"","what":"Viewing the data","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"","code":"par(mfrow=c(1,2), mar=c(1,1,1,1)) # Setting plot parameters ### Plotting trees with support values: ##  RAxML plot(raxml.tree) nodelabels(raxml.tree$node.label, adj = c(1, 0), frame = \"none\") ##  MrBayes plot(mrbayes.tree) nodelabels(mrbayes.tree$node.label, adj = c(1, 0), frame = \"none\") par(mfrow=c(1,1)) # Setting plot parameters # NeighborNet plot(Nnet,\"2D\") ## alternatively, # plot(Nnet,\"2D\")"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"a","dir":"Articles","previous_headings":"","what":"1A:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Identification edge bundles (black) neighbor-net (NN) network correspond branches (labelled 1-12) tree (maximum likelihood tree, case).","code":"# create a vector of labels for the network corresponding to edges in the tree edge.lab <- createLabel(Nnet, raxml.tree, raxml.tree$edge[,2], \"edge\") # could be also 1:27 instead of raxml.tree$edge[,2]  # Show the correspondingly labelled tree and network in R par(mfrow=c(1,2))   plot(raxml.tree, \"u\", rotate.tree = 180, cex=.7)  edgelabels(raxml.tree$edge[,2],col=\"blue\", frame=\"none\", cex=.7)  # find edges that are in the network but not in the tree edge.col <- rep(\"black\", nrow(Nnet$edge)) edge.col[ is.na(edge.lab) ] <- \"red\" # or a simpler alternative... edge.col <- createLabel(Nnet, raxml.tree, \"black\", nomatch=\"red\")  x <- plot(Nnet, edge.label = edge.lab, show.edge.label = T, \"2D\", edge.color = edge.col,                   col.edge.label = \"blue\", cex=.7) # the above plot function returns an invisible networx object and this object also   # contains the colors for the edges."},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"b","dir":"Articles","previous_headings":"","what":"1B:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Bootstrap support branches (branch labels) ML tree mapped corresponding edge bundles NN network. edges network found ML tree branches highlighted red.  can write SplitsTree viewing…","code":"# the scaler argument multiplies the confidence values. This is useful to switch # confidences values between total, percentage or ratios.    x <- addConfidences(Nnet,raxml.tree, scaler = .01) # find splits that are in the network but not in the tree split.col <- rep(\"black\", length(x$splits)) split.col[ !matchSplits(as.splits(x), as.splits(raxml.tree)) ] <- \"red\"  # simpler alternative... split.col2 <- createLabel(x, raxml.tree, label=\"black\", \"split\", nomatch=\"red\")  # Plotting in R out.x <- plot(x,\"2D\",show.edge.label=TRUE, split.color=split.col, col.edge.label = \"blue\") # write.nexus.networx(out.x,\"woodmouse.tree.support.nxs\") ## or we can also export the splits alone (for usage in software other than SplitsTree) # write.nexus.splits(as.splits(out.x),\"woodmouse.splits.support.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"c","dir":"Articles","previous_headings":"","what":"1C:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Frequencies bipartitions found bootstrap pseudoreplicates mapped corresponding edge bundles NN network using threshold 10% (.e. edge labelled occurs least 100 1000 ML-BS pseudoreplicates). Edge bundles found ML tree labelled using grey edges.","code":"y <- addConfidences(Nnet, as.splits(raxml.bootstrap)) edge.col <- createLabel(y, raxml.tree, label=\"black\", \"edge\", nomatch=\"grey\")  y <- plot(y,\"2D\",show.edge.label=TRUE, edge.color=edge.col) ## Write to SplitsTree for viewing # write.nexus.networx(y,\"NN.with.bs.support.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"extras","dir":"Articles","previous_headings":"","what":"Extras…","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"can also compare neighborNet consensusNet (Holland BR, Huber KT, Moulton V, Lockhart PJ,2004, Using consensus networks visualize contradictory evidence species phylogeny. Molecular Biology Evolution, 21, 1459-1461). Furthermore, can extract support values consensus network, place NeighborNet (similar process explained 1C ).","code":"cnet <- consensusNet(raxml.bootstrap,prob=0.10) edge.col <- createLabel(cnet, Nnet, label=\"black\", \"edge\", nomatch=\"grey\") cnet <- plot(cnet, \"2D\", show.edge.label = TRUE, edge.color=edge.col) edge.col <- createLabel(Nnet, cnet, label=\"black\", \"edge\", nomatch=\"grey\") z <- plot(Nnet, \"2D\", show.edge.label = TRUE, edge.color=edge.col) obj <- addConfidences(Nnet,cnet) plot(obj,\"2D\",show.edge.label=T, edge.color=edge.col, col.edge.label = \"blue\") ## Write to SplitsTree for viewing # write.nexus.networx(obj,\"Nnet.with.ML.Cnet.Bootstrap.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"section","dir":"Articles","previous_headings":"","what":"Intertwining phylogenetic trees and networks: R Example Script","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"four possible data patterns phylogenetic reconstruction: (1) patterns well supported network appear bootstrapped trees; (2) patterns well supported (part ) data/network appear optimized trees, .e. incompatible tree; (3) patterns weakly supported network appear optimized trees anyway, .e. compatible tree. demonstrate patterns showing relationships splits weights, NeighborNet splits graph, bootstrap bipartitions support bootstrap percentages plotted optimized tree dataset Wang, Braun, Kimball (2012). (advanced user figure…)","code":"Nnet <- read.nexus.networx(file.path(fdir,\"RAxML_distances.Wang.nxs\")) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bestTree.Wang.out\")) |> unroot() raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.Wang.out\"))  bs_splits <- as.splits(raxml.bootstrap) tree_splits <- as.splits(raxml.tree) |> unique() |> removeTrivialSplits() # we overwrite bootstrap values and set the weights  # to 1e-6 (almost zero), as we plot them on a log scale later on attr(bs_splits, \"weights\")[] <- 1e-6 # combine the splits from the bootstrap and neighbor net # and delete duplicates and add the confidence values # we get rid of trivial splits all_splits <- c(Nnet$splits, bs_splits) |> unique() |> removeTrivialSplits() |> addConfidences(bs_splits, scaler=100)  # For easier plotting we create a matrix with the confidences and  # weights as columns tab <- data.frame(SplitWeight = attr(all_splits, \"weights\"), Bootstrap=attr(all_splits, \"confidences\"), Tree=FALSE) # we add a logical variable pto indicate which splits are in the RAxML tree tab$Tree[matchSplits(tree_splits, all_splits, FALSE)] = TRUE  tab[is.na(tab[,\"Bootstrap\"]),\"Bootstrap\"] <- 0 tab[,\"Bootstrap\"] <- round(tab[,\"Bootstrap\"]) rownames(tab) <- apply(as.matrix(all_splits, zero.print = \".\", one.print = \"|\"), 1, paste0, collapse=\"\") tab[1:10,] ##                              SplitWeight Bootstrap  Tree ## ..||........................   0.0171433       100  TRUE ## ..||||......................   0.0013902        14 FALSE ## ..||||......|||||...........   0.0001589         0 FALSE ## ||.........................|   0.0027691         1 FALSE ## ||..........................   0.0840367       100  TRUE ## ...|||......................   0.0001773         0 FALSE ## ...|||........|.|...........   0.0003663         0 FALSE ## |.|.........................   0.0060907         0 FALSE ## ....||......................   0.0385909       100  TRUE ## ||||........................   0.0018195        34  TRUE col <- rep(\"blue\", nrow(tab)) col[tab[,\"Bootstrap\"]==0] <- \"green\" col[tab[,\"SplitWeight\"]==1e-6] <- \"red\"  pch = rep(19, nrow(tab)) pch[tab$Tree] <- 17  par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE) plot(tab[,\"SplitWeight\"], tab[,\"Bootstrap\"], log=\"x\", col=col, pch=pch,        xlab=\"Split weight (log scale)\", ylab=\"Bootstrap (%)\") legend(\"topright\", inset=c(-0.35,0), c(\"Pattern 1\", \"Pattern 2\", \"Pattern 3\", \"Pattern in the\\nbest tree\"), pch=c(19,19,19,17), col=c(\"blue\", \"green\", \"red\", \"black\"), bty=\"n\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"figure-4","dir":"Articles","previous_headings":"","what":"Figure 4","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"several option plotting co-phylogeny. following use cophylo function phytools package. Unfortunately function (yet) offer add confidences splits, can easily basic plot functions.  can compare consensus network different bootstrap values different genes.","code":"YCh <- read.tree(file.path(fdir, \"RAxML_bestTree.YCh\"))  mtG <- read.tree(file.path(fdir, \"RAxML_bestTree.mtG\"))  ncAI <- read.tree(file.path(fdir, \"RAxML_bestTree.AIs\"))  all_data <- read.tree(file.path(fdir, \"RAxML_bestTree.3moles\"))  YCh_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.YCh\"))  mtG_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.mtG\"))  ncAI_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.AIs\"))  all_data_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.3moles\")) library(phytools) par(mfrow=c(2,1)) obj <- cophylo(YCh, mtG)  plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1))   title(\"A. YCh                                    B. mtG\") obj <-  cophylo(ncAI, all_data) plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1)) title(\"C. ncAI                              D. All data\") par(mfrow=c(2,2), mar = c(2,2,4,2)) YCh <- plotBS(midpoint(YCh), YCh_boot, \"phylogram\", p=0, main = \"YCh\") mtG <- plotBS(midpoint(mtG), mtG_boot, \"phylogram\", p=0, main = \"mtG\") ncAI <- plotBS(midpoint(ncAI), ncAI_boot, \"phylogram\", p=0, main = \"ncAI\") all_data <- plotBS(midpoint(all_data), all_data_boot, \"phylogram\", p=0, main = \"All data\") par(mfrow=c(1,1)) cn <- consensusNet(c(YCh, mtG, ncAI)) cn <- addConfidences(cn, YCh_boot) |> addConfidences(mtG_boot, add=TRUE) |>    addConfidences(ncAI_boot, add=TRUE) |> addConfidences(all_data_boot, add=TRUE) plot(cn, \"2D\", show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"consensusnet","dir":"Articles","previous_headings":"","what":"consensusNet","title":"Splits and Networx","text":"consensusNet (Holland et al. 2004) generalization consensus tree. Instead representing splits (taxon bipartitions) occurring least 50% trees bootstrap MCMC sample one can use lower threshold explore competing splits. Note , basic implementation used , consensusNet edge lengths proportional frequency corresponding splits provided list trees. input consensusNet list trees .e. object class multiPhylo.   many cases, consensusNet return two incompatible (competing) splits. plotted planar (2-dimensional) graph. situation requires n-dimensional graph, maximum number dimensions equals maximum number incompatible splits. example, three alternative incompatible splits: (,B)|(C,D) vs. (,C)|(B,D) vs. (,D)|(B,C), need 3-dimensional graph show three alternatives. nice way get still good impression network plot 3D. result spinning graph similar rotatingNetworx","code":"set.seed(1) bs <- bootstrap.phyDat(yeast, FUN = function(x)nj(dist.hamming(x)),      bs=100) tree <- nj(dist.hamming(yeast)) par(\"mar\" = rep(1, 4)) tree <- plotBS(tree, bs, \"phylogram\") cnet <- consensusNet(bs, .3) plot(cnet, show.edge.label=TRUE) plot(cnet, \"3D\") # rotate 3d plot play3d(spin3d(axis=c(0,1,0), rpm=6), duration=10) # create animated gif file  movie3d(spin3d(axis=c(0,1,0), rpm=6), duration=10)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"neighbornet","dir":"Articles","previous_headings":"","what":"neighborNet","title":"Splits and Networx","text":"function neighborNet implements popular method Bryant Moulton (2004). Neighbor-Net algorithm essentially 2D-version Neighbor joining algorithm. Neighbour-net computed two steps: first computes circular ordering taxa data set; second step involves estimation edge weights using non-negative Least-Squares (nnls).  advantage Neighbor-Net returns circular split system can always displayed planar (2D) graph. plots displayed phangorn may (however) planar, re-plotting can give planar graph. unwanted behavior improved future version. rendering networx done using fantastic igraph package (Csardi Nepusz 2006).","code":"dm <- dist.hamming(yeast) nnet <- neighborNet(dm) par(\"mar\" = rep(1, 4)) plot(nnet)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"adding-support-values","dir":"Articles","previous_headings":"","what":"Adding support values","title":"Splits and Networx","text":"can use generic function addConfidences add (branch) support values tree, .e. object class phylo networx, splits phylo object. Neighbor-Net object computed provides support values. can add support values tree computed splits (edges) shared objects.  Analogously, can also add support values tree:","code":"nnet <- addConfidences(nnet, tree) par(\"mar\" = rep(1, 4)) plot(nnet, show.edge.label=TRUE) tree2 <- rNNI(tree, 2) tree2 <- addConfidences(tree2, tree) # several support values are missing par(\"mar\" = rep(1, 4)) plot(tree2, show.node.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"estimating-edge-weights-nnls","dir":"Articles","previous_headings":"","what":"Estimating edge weights (nnls)","title":"Splits and Networx","text":"Consensus networks, hand, provide primarily information support values corresponding split, information actual difference taxon bipartitions defined split. example, one may interested alternative support values correspond actual genetic distance involved taxa. Given distance matrix, can estimate edge weights using non-negative Least-Squares, plot onto consensusNet splits graph.","code":"cnet <- nnls.networx(cnet, dm) par(\"mar\" = rep(1, 4)) plot(cnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"import-and-export-networks-advanced-functions-for-networx-objects","dir":"Articles","previous_headings":"Estimating edge weights (nnls)","what":"Import and export networks, advanced functions for networx objects","title":"Splits and Networx","text":"functions read.nexus.networx write.nexus.networx can read write nexus files SplitsTree (Huson Bryant 2006). Check-new vignette IntertwiningTreesAndNetworks additional functions, examples, advanced applications.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Splits and Networx","text":"","code":"sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.9.0.9000 ape_5.6-2           ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.9        highr_0.9         bslib_0.4.0       compiler_4.2.1    ##  [5] jquerylib_0.1.4   prettydoc_0.4.1   tools_4.2.1       digest_0.6.29     ##  [9] jsonlite_1.8.0    evaluate_0.15     memoise_2.0.1     nlme_3.1-157      ## [13] lattice_0.20-45   pkgconfig_2.0.3   rlang_1.0.4       Matrix_1.4-1      ## [17] fastmatch_1.1-3   igraph_1.3.4      cli_3.3.0         yaml_2.3.5        ## [21] parallel_4.2.1    pkgdown_2.0.6     xfun_0.31         fastmap_1.1.0     ## [25] stringr_1.4.0     knitr_1.39        desc_1.4.1        generics_0.1.3    ## [29] fs_1.5.2          sass_0.4.2        systemfonts_1.0.4 rprojroot_2.0.3   ## [33] grid_4.2.1        R6_2.5.1          textshaping_0.3.6 rmarkdown_2.14    ## [37] purrr_0.3.4       magrittr_2.0.3    codetools_0.2-18  htmltools_0.5.3   ## [41] quadprog_1.5-8    ragg_1.2.2        stringi_1.7.8     cachem_1.0.6"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimating phylogenetic trees with phangorn","text":"notes enable user estimate phylogenetic trees alignment data different methods using phangorn package (Schliep 2011) . Several functions package also described detail (Paradis 2012). theoretical background methods see e.g. (Felsenstein 2004)(Yang 2006). document illustrates package features estimate phylogenetic trees using different reconstruction methods. Small adaptations scripts section @ref(appendix) enable user perform phylogenetic analyses.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Estimating phylogenetic trees with phangorn","text":"first thing read alignment. Unfortunately exists many different file formats alignments can stored . function read.phyDat used read alignment. several functions read alignments depending format data set (“nexus”, “phylip”, “fasta”) kind data (amino acid nucleotides) ape package (Paradis Schliep 2019) phangorn. function read.phyDat calls functions transform phyDat object. specific parameter settings available look help files function read.dna (phylip, fasta, clustal format), read.nexus.data nexus files. amino acid data additional read.aa called. start analysis loading phangorn package reading alignment.","code":"library(ape) library(phangorn) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"distance-based-methods","dir":"Articles","previous_headings":"","what":"Distance based methods","title":"Estimating phylogenetic trees with phangorn","text":"reading alignment can build first tree distance based methods. function dist.dna ape package computes distances many DNA substitution models. use function dist.dna transform data class DNAbin. amino acids function dist.ml offers common substitution models (example “WAG”, “JTT”, “LG”, “Dayhoff”, “cpREV”, “mtmam”, “mtArt”, “MtZoa” “mtREV24”). constructing distance matrix reconstruct rooted tree UPGMA alternatively unrooted tree using Neighbor Joining (Saitou Nei 1987)(Studier Keppler 1988). distance methods like fastme available ape package. can plot trees treeUPGMA treeNJ commands: Rooted UPGMA tree. Unrooted NJ tree.","code":"dm  <- dist.ml(primates) treeUPGMA  <- upgma(dm) treeNJ  <- NJ(dm) plot(treeUPGMA, main=\"UPGMA\") plot(treeNJ, \"unrooted\", main=\"NJ\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"bootstrap","dir":"Articles","previous_headings":"Distance based methods","what":"Bootstrap","title":"Estimating phylogenetic trees with phangorn","text":"run bootstrap need first write function computes tree alignment. first need compute distance matrix afterwards compute tree. function can give bootstrap.phyDat function. new syntax R 4.1 can written bit shorter: Finally can plot tree bootstrap values added: Rooted UPGMA tree. Distance based methods fast use UPGMA NJ tree starting trees maximum parsimony maximum likelihood analyses.","code":"fun <- function(x) upgma(dist.ml(x)) bs_upgma <- bootstrap.phyDat(primates,  fun) bs_upgma <- bootstrap.phyDat(primates,  \\(x){dist.ml(x) |> upgma}) plotBS(treeUPGMA, bs_upgma, main=\"UPGMA\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"parsimony","dir":"Articles","previous_headings":"","what":"Parsimony","title":"Estimating phylogenetic trees with phangorn","text":"function parsimony returns parsimony score, number changes least necessary describe data given tree. can compare parsimony score two trees computed far: function users want use infer phylogenies MP pratchet, implementation parsimony ratchet (Nixon 1999). allows escape local optima find better trees performing NNI / SPR rearrangements. current implementation Create bootstrap data set \\(D_b\\) original data set. Take current best tree perform tree rearrangements \\(D_b\\) save bootstrap tree \\(T_b\\). Use \\(T_b\\) perform tree rearrangements original data set. trees lower parsimony score currently best tree replace . Iterate 1:3 either given number iteration reached improvements recorded number iterations. set minimum iteration parsimony ratchet 100 iterations. ratchet performed implicitly bootstrap resampling already computed branch support, case least 100 bootstrap iterations. function may returns several best trees, trees branch length assigned yet. assigning edge weights prune away internal edges length, trees may contain multifurcations. trees might differed edges length 0. parsimony ratchet implicitly performs bootstrap analysis (step 1). make use store trees visited. allows us add bootstrap support values tree.  treeRatchet list tree, object class multiPhylo can subset -th trees treeRatchet[[]]. cases pratchet enough use, phangorn exports function might useful. random.addition computes random addition can used generate starting trees. function optim.parsimony performs tree rearrangements find trees lower parsimony score. tree rearrangement implemented nearest-neighbor interchanges (NNI) subtree pruning regrafting (SPR). later one works far fitch algorithm.","code":"parsimony(treeUPGMA, primates) ## [1] 751 parsimony(treeNJ, primates) ## [1] 746 treeRatchet  <- pratchet(primates, trace = 0, minit=100) parsimony(treeRatchet, primates) ## [1] 746 treeRatchet  <- acctran(treeRatchet, primates) treeRatchet  <- di2multi(treeRatchet) if(inherits(treeRatchet, \"multiPhylo\")){   treeRatchet <- unique(treeRatchet) } plotBS(midpoint(treeRatchet), type=\"phylogram\") add.scale.bar() treeRA <- random.addition(primates) treeSPR  <- optim.parsimony(treeRA, primates) ## Final p-score 750 after  1 nni operations parsimony(c(treeRA, treeSPR), primates) ## [1] 757 750"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"branch-and-bound","dir":"Articles","previous_headings":"Parsimony","what":"Branch and bound","title":"Estimating phylogenetic trees with phangorn","text":"data sets species also possible find parsimonious trees using branch bound algorithm (Hendy Penny 1982). data sets 10 taxa can take long time depends strongly tree like data . 20-30 taxa take almost forever.","code":"(trees <- bab(primates[1:10,])) ## 1 phylogenetic tree"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"maximum-likelihood","dir":"Articles","previous_headings":"","what":"Maximum likelihood","title":"Estimating phylogenetic trees with phangorn","text":"last method describe vignette Maximum Likelihood (ML) introduced Felsenstein (Felsenstein 1981). can easily compute likelihood tree given data function pml returns object class pml. object contains data, tree many different parameters model like likelihood. many generic functions class pml available, allow handling objects. object fit just estimated likelihood tree got supplied, branch length optimized Jukes-Cantor model yet, can done function optim.pml. default valuespml estimate Jukes-Cantor model. generic function update allows change parameters. change model GTR + \\(\\Gamma(4)\\) + model optimize parameters. control parameters thresholds fitting process can changed. want just suppress output fitting process. larger trees NNI rearrangements often get stuck local maximum. added two stochastic algorithms improve topology search. first (set rearrangement=\"stochastic\") performs stochastic rearrangements similar (Nguyen et al. 2015), makes random NNI permutation tree, gets optimized escape local optima. second option (rearrangement=“ratchet”) perform likelihood ratchet (Vos 2003). algorithms may find better trees also take time.","code":"fit <- pml(treeNJ, data=primates) fit ## model: JC  ## loglikelihood: -3074.952  ## unconstrained loglikelihood: -1230.335  ##  ## Rate matrix: ##   a c g t ## a 0 1 1 1 ## c 1 0 1 1 ## g 1 1 0 1 ## t 1 1 1 0 ##  ## Base frequencies:   ##    a    c    g    t  ## 0.25 0.25 0.25 0.25 methods(class=\"pml\") ## [1] AICc   anova  BIC    logLik plot   print  simSeq update vcov   ## see '?methods' for accessing help and source code fitJC  <- optim.pml(fit, rearrangement=\"NNI\") ## optimize edge weights:  -3074.952 --> -3068.417  ## optimize edge weights:  -3068.417 --> -3068.417  ##  optimize topology:  -3068.417 --> -3068.295  ##  NNI moves:  1  ##  optimize topology:  -3068.295 --> -3068.295  ##  NNI moves:  0  ## NNI moves:  1  ## optimize edge weights:  -3068.295 --> -3068.295  ##  optimize topology:  -3068.295 --> -3068.295  ##  NNI moves:  0  ## NNI moves:  0 logLik(fitJC) ## 'log Lik.' -3068.295 (df=25) fitGTR <- update(fit, k=4, inv=0.2) fitGTR <- optim.pml(fitGTR, model=\"GTR\", optInv=TRUE, optGamma=TRUE,     rearrangement = \"NNI\", control = pml.control(trace = 0)) fitGTR ## model: GTR+G(4)+I  ## loglikelihood: -2608.716  ## unconstrained loglikelihood: -1230.335  ## Proportion of invariant sites: 0.005672546  ## Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.987816  ##  ## Rate matrix: ##            a           c           g          t ## a  0.0000000  0.61621416 36.10557798  0.3768079 ## c  0.6162142  0.00000000  0.00616504 15.1584070 ## g 36.1055780  0.00616504  0.00000000  1.0000000 ## t  0.3768079 15.15840700  1.00000000  0.0000000 ##  ## Base frequencies:   ##          a          c          g          t  ## 0.39340516 0.37910510 0.04024609 0.18724365 fitGTR <- optim.pml(fitGTR, model=\"GTR\", optInv=TRUE, optGamma=TRUE,     rearrangement = \"stochastic\", control = pml.control(trace = 0)) fitGTR ## model: GTR+G(4)+I  ## loglikelihood: -2607.142  ## unconstrained loglikelihood: -1230.335  ## Proportion of invariant sites: 0.005570562  ## Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.650239  ##  ## Rate matrix: ##            a           c           g          t ## a  0.0000000  0.96274464 84.80717953  0.6526146 ## c  0.9627446  0.00000000  0.00458977 32.6369015 ## g 84.8071795  0.00458977  0.00000000  1.0000000 ## t  0.6526146 32.63690148  1.00000000  0.0000000 ##  ## Base frequencies:   ##          a          c          g          t  ## 0.39631757 0.37882161 0.04026462 0.18459620"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"model-selection","dir":"Articles","previous_headings":"Maximum likelihood","what":"Model selection","title":"Estimating phylogenetic trees with phangorn","text":"can compare nested models JC GTR + \\(\\Gamma(4)\\) + model using likelihood ratio statistic Shimodaira-Hasegawa  test AIC alternative use function modelTest compare different nucleotide protein models AIC, AICc BIC, similar popular programs ModelTest ProtTest (D. Posada Crandall 1998), (David Posada 2008), (Abascal, Zardoya, Posada 2005). default available nucleotide amino acid models available compared. can select common models: results modelTest illustrated following table: thresholds optimization modelTest strict optim.pml tree rearrangements performed. modelTest computes optimizes lot models waste computer time save results. results saved call together optimized trees environment function .pml evaluates call get pml object back use optimization analysis.","code":"anova(fitJC, fitGTR) ## Likelihood Ratio Test Table ##   Log lik. Df Df change Diff log lik. Pr(>|Chi|)     ## 1  -3068.3 25                                        ## 2  -2607.1 35        10        922.31  < 2.2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 SH.test(fitGTR, fitJC) ##      Trees      ln L Diff ln L p-value ## [1,]     1 -2607.142    0.0000  0.5014 ## [2,]     2 -3068.295  461.1532  0.0000 AIC(fitJC) ## [1] 6186.59 AIC(fitGTR) ## [1] 5284.284 AICc(fitGTR) ## [1] 5297.141 BIC(fitGTR) ## [1] 5404.92 mt <- modelTest(primates) mt <- modelTest(primates, model=c(\"JC\", \"F81\", \"K80\", \"HKY\", \"SYM\", \"GTR\")) (fit <- as.pml(mt, \"HKY+G+I\")) ## model: HKY+G(4)+I  ## loglikelihood: -2612.446  ## unconstrained loglikelihood: -1230.335  ## Proportion of invariant sites: 0.002733786  ## Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.127185  ##  ## Rate matrix: ##          a        c        g        t ## a  0.00000  1.00000 56.03063  1.00000 ## c  1.00000  0.00000  1.00000 56.03063 ## g 56.03063  1.00000  0.00000  1.00000 ## t  1.00000 56.03063  1.00000  0.00000 ##  ## Base frequencies:   ##          a          c          g          t  ## 0.42049741 0.36225436 0.04393528 0.17331294 (fit <- as.pml(mt, \"BIC\")) ## model: HKY+G(4)  ## loglikelihood: -2612.641  ## unconstrained loglikelihood: -1230.335  ## Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.145192  ##  ## Rate matrix: ##          a        c        g        t ## a  0.00000  1.00000 51.43709  1.00000 ## c  1.00000  0.00000  1.00000 51.43709 ## g 51.43709  1.00000  0.00000  1.00000 ## t  1.00000 51.43709  1.00000  0.00000 ##  ## Base frequencies:   ##          a          c          g          t  ## 0.41934078 0.36288855 0.04388863 0.17388204"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"bootstrap-1","dir":"Articles","previous_headings":"Maximum likelihood","what":"Bootstrap","title":"Estimating phylogenetic trees with phangorn","text":"last may want apply bootstrap test well edges tree supported: Now can plot tree bootstrap support values edges also look consensusNet identify potential conflict. Tree bootstrap support. Unrooted tree (midpoint rooted) bootstrap support values. ConsensusNet bootstrap sample. Several analyses, e.g.bootstrap modelTest, can computationally demanding, nowadays computers several cores one can distribute computations using parallel package. However possible use approach R running command line (“X11”), using GUI (example “Aqua” Macs) unfortunately parallel package work Windows.","code":"bs <- bootstrap.pml(fitJC, bs=100, optNni=TRUE,     control = pml.control(trace = 0)) plotBS(midpoint(fitJC$tree), bs, p = 50, type=\"p\") cnet <- consensusNet(bs, p=0.2) plot(cnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"molecular-dating-with-a-strict-clock-for-ultrametric-and-tipdated-phylogenies","dir":"Articles","previous_headings":"Maximum likelihood","what":"Molecular dating with a strict clock for ultrametric and tipdated phylogenies","title":"Estimating phylogenetic trees with phangorn","text":"implemented strict clock described (Felsenstein 2004), p. 266 allowing infer ultrametric tip-dated phylogenies. need starting tree fulfills assumptions, either tree ultrametric constraints given tip dates. ultrametric starting tree starting tree can use UPGMA WPGMA tree. optimize tree optim.pml make sure set set optRooted = TRUE tip-dated need additionally set optRate=TRUE!  phangorn also can estimate tipdated phylogenies. use example H3N2 virus data set treetime (Sagulenko, Puller, Neher 2018). Additionally alignment also need read data containing dates tips. use internal function candidate_tree compute fast starting tree constraints given dates. can use optim.pml optimize tree parameters. last plot tree timescale.  loglikelihood lower unrooted tree, keep mind rooted trees use less parameters. unrooted trees estimate one edge length parameter tree, ultrametric trees estimate parameter internal node tipdated trees one additional parameter rate.","code":"fit_strict <- pml(treeUPGMA, data=primates, k=4, bf=baseFreq(primates)) fit_strict <- optim.pml(fit_strict, model=\"GTR\", optRooted = TRUE,                          rearrangement = \"NNI\", optGamma = TRUE, optInv = TRUE,                          control = pml.control(trace = 0)) plot(fit_strict) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") tmp <- read.csv(file.path(fdir,\"H3N2_NA_20.csv\")) H3N2 <- read.phyDat(file.path(fdir,\"H3N2_NA_20.fasta\"), format=\"fasta\") dates <- setNames(tmp$numdate_given, tmp$name) tree <- candidate_tree(H3N2, \"tipdated\", tip.dates=dates) fit_td <- pml(tree, H3N2, rate=attr(tree, \"rate\"))  fit_td <- optim.pml(fit_td, model=\"GTR\", rearrangement=\"NNI\", optRooted=TRUE,                      optRate=TRUE, control=pml.control(trace=0)) tree_td <- fit_td$tree root_time <- max(dates) - max(node.depth.edgelength(tree_td)) plot(tree_td, show.tip.label = FALSE) axisPhylo(root.time = root_time, backward = FALSE)"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"standard-scripts-for-nucleotide-analysis","dir":"Articles","previous_headings":"Appendix","what":"Standard scripts for nucleotide analysis","title":"Estimating phylogenetic trees with phangorn","text":"provide two standard scripts can adapted common tasks. likely arguments read.phyDat adapted accommodate file format. scripts assume parallel package works platform, see comments .","code":"library(phangorn) file <- \"myfile\" dat <- read.phyDat(file) dm <- dist.ml(dat, \"F81\") tree <- NJ(dm) # as alternative for a starting tree: tree <- pratchet(dat)          # parsimony tree tree <- nnls.phylo(tree, dm)   # need edge weights  # 1. alternative: quick and dirty: GTR + G fitStart <- pml(tree, dat, k=4) fit <- optim.pml(fitStart, model=\"GTR\", optGamma=TRUE, rearrangement=\"stochastic\")  # 2. alternative: choose with modelTest mt <- modelTest(dat, tree=tree, multicore=TRUE) mt[order(mt$BIC),] # choose best model from the table according to BIC (default) fitStart <- as.pml(mt) # assume the model GTR + G + I fit <- optim.pml(fitStart, rearrangement = \"stochastic\",     optGamma=TRUE, optInv=TRUE, model=\"GTR\") bs <- bootstrap.pml(fit, bs=100, optNni=TRUE, multicore=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"standard-scripts-for-amino-acid-analysis","dir":"Articles","previous_headings":"Appendix","what":"Standard scripts for amino acid analysis","title":"Estimating phylogenetic trees with phangorn","text":"can specify different several models build can specify, e.g. “WAG”, “JTT”, “Dayhoff”, “LG”. Optimizing rate matrix amino acids possible, take long, long time need large alignment estimate parameters. make sure set optBf=FALSE optQ=FALSE function optim.pml, also default.","code":"library(phangorn) file <- \"myfile\" dat <- read.phyDat(file, type = \"AA\") dm <- dist.ml(dat, model=\"JTT\") tree <- NJ(dm)  # parallel will only work safely from command line # and not at all windows (mt <- modelTest(dat, model=c(\"JTT\", \"LG\", \"WAG\"),     multicore=TRUE)) # run all available amino acid models (mt <- modelTest(dat, model=\"all\", multicore=TRUE))  fitStart <- as.pml(mt)  fitNJ <- pml(tree, dat, model=\"JTT\", k=4, inv=.2) fit <- optim.pml(fitNJ, rearrangement = \"stochastic\",     optInv=TRUE, optGamma=TRUE) fit  bs <- bootstrap.pml(fit, bs=100, optNni=TRUE, multicore=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Estimating phylogenetic trees with phangorn","text":"","code":"## R version 4.2.1 (2022-06-23) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] knitr_1.39          phangorn_2.9.0.9000 ape_5.6-2           ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.9        highr_0.9         bslib_0.4.0       compiler_4.2.1    ##  [5] jquerylib_0.1.4   prettydoc_0.4.1   tools_4.2.1       digest_0.6.29     ##  [9] jsonlite_1.8.0    evaluate_0.15     memoise_2.0.1     nlme_3.1-157      ## [13] lattice_0.20-45   pkgconfig_2.0.3   rlang_1.0.4       Matrix_1.4-1      ## [17] fastmatch_1.1-3   igraph_1.3.4      cli_3.3.0         yaml_2.3.5        ## [21] parallel_4.2.1    pkgdown_2.0.6     xfun_0.31         fastmap_1.1.0     ## [25] stringr_1.4.0     desc_1.4.1        generics_0.1.3    fs_1.5.2          ## [29] sass_0.4.2        systemfonts_1.0.4 rprojroot_2.0.3   grid_4.2.1        ## [33] R6_2.5.1          textshaping_0.3.6 rmarkdown_2.14    purrr_0.3.4       ## [37] magrittr_2.0.3    codetools_0.2-18  htmltools_0.5.3   quadprog_1.5-8    ## [41] ragg_1.2.2        stringi_1.7.8     cachem_1.0.6"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Klaus Schliep. Author, maintainer. Emmanuel Paradis. Author. Leonardo de Oliveira Martins. Author. Alastair Potts. Author. Tim W. White. Author. Cyrill Stachniss. Contributor. Michelle Kendall. Contributor. Keren Halabi. Contributor. Richel Bilderbeek. Contributor. Kristin Winchell. Contributor. Liam Revell. Contributor. Mike Gilchrist. Contributor. Jeremy Beaulieu. Contributor. Brian O'Meara. Contributor. Long Qu. Contributor.","code":""},{"path":"https://klausvigo.github.io/phangorn/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schliep K.P. 2011. phangorn: phylogenetic analysis R. Bioinformatics, 27(4) 592-593 Schliep, K., Potts, . J., Morrison, D. ., Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecology Evolution, 8: 1212--1220. doi: 10.1111/2041-210X.12760","code":"@Article{,   title = {phangorn: phylogenetic analysis in R},   author = {K.P. Schliep},   journal = {Bioinformatics},   year = {2011},   volume = {27},   number = {4},   pages = {592--593},   doi = {10.1093/bioinformatics/btq706}, } @Article{,   author = {{Schliep} and {Klaus} and {Potts} and Alastair J. and {Morrison} and David A. and {Grimm} and Guido W.},   title = {Intertwining phylogenetic trees and networks},   journal = {Methods in Ecology and Evolution},   volume = {8},   number = {10},   pages = {1212--1220},   keywords = {exploratory data analysis, networks, phangorn, R, trees},   year = {2017}, }"},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"phangorn-","dir":"","previous_headings":"","what":"Phylogenetic Reconstruction and Analysis","title":"Phylogenetic Reconstruction and Analysis","text":"phangorn package phylogenetic reconstruction analysis R language. phangorn offers possibility reconstructing phylogenies distance based methods, maximum parsimony maximum likelihood (ML) performing Hadamard conjugation. Extending general ML framework, package provides possibility estimating mixture partition models. Furthermore, phangorn offers several functions comparing trees, phylogenetic models splits, simulating character data performing congruence analyses. can install - latest released version install.packages(\"phangorn\") - latest development version remotes::install_github(\"KlausVigo/phangorn\") install development version may need install Biostrings seqLogo package bioconductor first: Also development version usually depends latest ape development version information download can found . Additionally may need install windows Rtools mac XCode GFortran. use phangorn please cite: Schliep K.P. 2011. phangorn: phylogenetic analysis R. Bioinformatics, 27(4) 592-593","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(c(\"Biostrings\", \"seqLogo\"))"},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Phylogenetic Reconstruction and Analysis","text":"phangorn licensed GPLv2.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":null,"dir":"Reference","previous_headings":"","what":"tree utility function — Ancestors","title":"tree utility function — Ancestors","text":"Functions describing relationships among phylogenetic nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"tree utility function — Ancestors","text":"","code":"Ancestors(x, node, type = c(\"all\", \"parent\"))  allDescendants(x)  Children(x, node)  Descendants(x, node, type = c(\"tips\", \"children\", \"all\"))  Siblings(x, node, include.self = FALSE)  mrca.phylo(x, node = NULL, full = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"tree utility function — Ancestors","text":"x tree (phylo object). node integer vector integers corresponding node ID type specify whether return just direct children / parents include.self whether include self list siblings full logical indicating whether return MRCAs among tips nodes (TRUE); default return MRCAs among tips.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"tree utility function — Ancestors","text":"vector list containing indices nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"tree utility function — Ancestors","text":"functions inspired treewalk phylobase package, work S3 phylo objects.  nodes indices given edge matrix phylo object. taxon labels indices can easily derived matching tip.label argument phylo object, see example .  functions allow node either scalar vector.  mrca faster version mrca ape, phangorn dependencies. argument node missing function evaluated nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"tree utility function — Ancestors","text":"allDescendants(): list descendant nodes node","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"tree utility function — Ancestors","text":"","code":"tree <- rtree(10) plot(tree, show.tip.label = FALSE) nodelabels() tiplabels()  Ancestors(tree, 1:3, \"all\") #> [[1]] #> [1] 11 #>  #> [[2]] #> [1] 13 12 11 #>  #> [[3]] #> [1] 13 12 11 #>  Children(tree, 11) #> [1]  1 12 Descendants(tree, 11, \"tips\") #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  Siblings(tree, 3) #> [1] 2 # Siblings of all nodes Siblings(tree) #> [[1]] #> [1] 12 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 2 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> [1] 4 #>  #> [[6]] #> [1] 18 #>  #> [[7]] #> [1] 8 #>  #> [[8]] #> [1] 7 #>  #> [[9]] #> [1] 10 #>  #> [[10]] #> [1] 9 #>  #> [[11]] #> NULL #>  #> [[12]] #> [1] 1 #>  #> [[13]] #> [1] 14 #>  #> [[14]] #> [1] 13 #>  #> [[15]] #> [1] 19 #>  #> [[16]] #> [1] 17 #>  #> [[17]] #> [1] 16 #>  #> [[18]] #> [1] 6 #>  #> [[19]] #> [1] 15 #>  mrca.phylo(tree, 1:3) #> [1] 11 mrca.phylo(tree, match(c(\"t1\", \"t2\", \"t3\"), tree$tip)) #> [1] 15 mrca.phylo(tree) #>     t9 t5 t7 t1 t2 t8 t3 t6 t4 t10 #> t9   1 11 11 11 11 11 11 11 11  11 #> t5  11  2 13 12 12 12 12 12 12  12 #> t7  11 13  3 12 12 12 12 12 12  12 #> t1  11 12 12  4 16 15 15 15 14  14 #> t2  11 12 12 16  5 15 15 15 14  14 #> t8  11 12 12 15 15  6 17 17 14  14 #> t3  11 12 12 15 15 17  7 18 14  14 #> t6  11 12 12 15 15 17 18  8 14  14 #> t4  11 12 12 14 14 14 14 14  9  19 #> t10 11 12 12 14 14 14 14 14 19  10 # same as mrca(tree), but faster for large trees"},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":null,"dir":"Reference","previous_headings":"","what":"Consistency Index and Retention Index — CI","title":"Consistency Index and Retention Index — CI","text":"CI RI compute Consistency Index (CI) Retention Index (RI).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consistency Index and Retention Index — CI","text":"","code":"CI(tree, data, cost = NULL, sitewise = FALSE)  RI(tree, data, cost = NULL, sitewise = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consistency Index and Retention Index — CI","text":"tree tree start nni search . data object class phyDat containing sequences. cost cost matrix transitions two states. sitewise return CI/RI alignment sitewise","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Consistency Index and Retention Index — CI","text":"Consistency Index defined minimum number changes divided number changes required tree (parsimony score). Consistency Index equal one homoplasy. Retention Index defined $$RI = \\frac{MaxChanges - ObsChanges}{MaxChanges - MinChanges}$$","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":null,"dir":"Reference","previous_headings":"","what":"Laurasiatherian data (AWCMEE) — Laurasiatherian","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"Laurasiatherian RNA sequence data","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"Data taken former repository Allan Wilson Centre converted R format klaus.schliep@gmail.com.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"","code":"data(Laurasiatherian) str(Laurasiatherian) #> List of 47 #>  $ Platypus  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Wallaroo  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Possum    : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Bandicoot : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Opposum   : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Armadillo : int [1:1605] 2 1 2 1 3 3 4 2 4 3 ... #>  $ Elephant  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Aardvark  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Tenrec    : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Hedghog   : int [1:1605] 1 4 1 1 3 3 4 2 4 3 ... #>  $ Gymnure   : int [1:1605] 1 1 1 1 3 3 4 2 4 3 ... #>  $ Mole      : int [1:1605] 1 1 1 1 3 3 4 4 4 3 ... #>  $ Shrew     : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Rbat      : int [1:1605] 2 1 4 1 3 3 2 4 4 2 ... #>  $ FlyingFox : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ RyFlyFox  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ FruitBat  : int [1:1605] 4 1 4 1 3 3 4 4 4 3 ... #>  $ LongTBat  : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Horse     : int [1:1605] 2 1 4 1 3 3 2 4 4 3 ... #>  $ Donkey    : int [1:1605] 2 1 4 1 3 3 2 4 4 3 ... #>  $ WhiteRhino: int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ IndianRhin: int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Pig       : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Alpaca    : int [1:1605] 2 1 2 1 3 3 4 4 4 1 ... #>  $ Cow       : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Sheep     : int [1:1605] 4 1 4 1 3 3 4 4 4 3 ... #>  $ Hippo     : int [1:1605] 4 1 2 1 3 3 4 4 4 3 ... #>  $ FinWhale  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ BlueWhale : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ SpermWhale: int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Rabbit    : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Pika      : int [1:1605] 1 1 4 1 3 3 4 4 4 3 ... #>  $ Squirrel  : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Dormouse  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ GuineaPig : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Mouse     : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Vole      : int [1:1605] 1 1 1 1 3 3 4 4 4 3 ... #>  $ CaneRat   : int [1:1605] 2 1 1 1 4 3 4 4 4 3 ... #>  $ Baboon    : int [1:1605] 1 1 4 1 3 3 2 4 4 3 ... #>  $ Human     : int [1:1605] 1 1 4 1 3 3 4 4 4 3 ... #>  $ Loris     : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Cebus     : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Cat       : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Dog       : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ HarbSeal  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ FurSeal   : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ GraySeal  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  - attr(*, \"class\")= chr \"phyDat\" #>  - attr(*, \"weight\")= int [1:1605] 1 5 1 444 3 314 1 1 328 1 ... #>  - attr(*, \"nr\")= int 1605 #>  - attr(*, \"nc\")= num 4 #>  - attr(*, \"index\")= int [1:3179] 1 2 3 4 5 6 7 8 9 6 ... #>  - attr(*, \"levels\")= chr [1:4] \"a\" \"c\" \"g\" \"t\" #>  - attr(*, \"allLevels\")= chr [1:18] \"a\" \"c\" \"g\" \"t\" ... #>  - attr(*, \"type\")= chr \"DNA\" #>  - attr(*, \"contrast\")= num [1:18, 1:4] 1 0 0 0 0 1 1 1 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:4] \"a\" \"c\" \"g\" \"t\""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbor-Joining — NJ","title":"Neighbor-Joining — NJ","text":"function performs neighbor-joining tree estimation Saitou Nei (1987). UNJ unweighted version Gascuel (1997).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbor-Joining — NJ","text":"","code":"NJ(x)  UNJ(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbor-Joining — NJ","text":"x distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbor-Joining — NJ","text":"object class \"phylo\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Neighbor-Joining — NJ","text":"Saitou, N. Nei, M. (1987) neighbor-joining method: new method reconstructing phylogenetic trees. Molecular Biology Evolution, 4, 406--425. Studier, J. Keppler, K. J. (1988) Note Neighbor-Joining Algorithm Saitou Nei. Molecular Biology Evolution, 6, 729--731. Gascuel, O. (1997) Concerning NJ algorithm unweighted version, UNJ. Birkin et. al. Mathematical Hierarchies Biology, 149--170.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighbor-Joining — NJ","text":"Klaus P. Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighbor-Joining — NJ","text":"","code":"data(Laurasiatherian) dm <- dist.ml(Laurasiatherian) tree <- NJ(dm) plot(tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Shimodaira-Hasegawa Test — SH.test","title":"Shimodaira-Hasegawa Test — SH.test","text":"function computes Shimodaira--Hasegawa test set trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shimodaira-Hasegawa Test — SH.test","text":"","code":"SH.test(..., B = 10000, data = NULL, weight = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shimodaira-Hasegawa Test — SH.test","text":"... either series objects class \"pml\" separated commas, list containing objects object class \"pmlPart\" matrix containing site-wise likelihoods columns. B number bootstrap replicates. data object class \"phyDat\". weight matrix site (log-)likelihoods supplied optional vector containing number occurrences site pattern.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shimodaira-Hasegawa Test — SH.test","text":"numeric vector P-value associated tree given ....","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shimodaira-Hasegawa Test — SH.test","text":"Shimodaira, H. Hasegawa, M. (1999) Multiple comparisons log-likelihoods applications phylogenetic inference. Molecular Biology Evolution, 16, 1114--1116.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Shimodaira-Hasegawa Test — SH.test","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shimodaira-Hasegawa Test — SH.test","text":"","code":"data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree1 <- NJ(dm) tree2 <- unroot(upgma(dm)) fit1 <- pml(tree1, Laurasiatherian) fit2 <- pml(tree2, Laurasiatherian) fit1 <- optim.pml(fit1) # optimize edge weights #> optimize edge weights:  -54807.68 --> -54290.26  #> optimize edge weights:  -54290.26 --> -54290.26  #> optimize edge weights:  -54290.26 --> -54290.26  fit2 <- optim.pml(fit2) #> optimize edge weights:  -55623.41 --> -54911.33  #> optimize edge weights:  -54911.33 --> -54911.33  #> optimize edge weights:  -54911.33 --> -54911.33  # with pml objects as input SH.test(fit1, fit2, B=1000) #>      Trees      ln L Diff ln L p-value #> [1,]     1 -54290.26    0.0000   0.496 #> [2,]     2 -54911.33  621.0767   0.000 # in real analysis use larger B, e.g. 10000  # with matrix as input X <- matrix(c(fit1$siteLik, fit2$siteLik), ncol=2) SH.test(X, weight=attr(Laurasiatherian, \"weight\"), B=1000) #>      Trees      ln L Diff ln L p-value #> [1,]     1 -54290.26    0.0000   0.478 #> [2,]     2 -54911.33  621.0767   0.000 if (FALSE) { example(pmlPart) SH.test(sp, B=1000) }"},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"function computes Swofford--Olsen--Waddell--Hillis (SOWH) test, parametric bootstrap test. function computational demanding likely slow.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"","code":"SOWH.test(x, n = 100, restricted = list(optNni = FALSE), optNni = TRUE,   trace = 1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"x object class \"pml\". n number bootstrap replicates. restricted list restricted parameter settings. optNni Logical value indicating whether topology gets optimized (NNI). trace Show output computations. ... arguments passed \"optim.pml\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"object class SOWH. list three elements, one matrix containing bootstrap replicate (log-) likelihood restricted unrestricted estimate two pml objects restricted unrestricted model.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"SOWH.test performs parametric bootstrap test compare two trees. makes extensive use simSeq optim.pml can take quite long.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"Goldman, N., Anderson, J. P., Rodrigo, . G. (2000) Likelihood -based tests topologies phylogenetics. Systematic Biology 49 652-670. Swofford, D.L., Olsen, G.J., Waddell, P.J. Hillis, D.M. (1996) Phylogenetic Inference Hillis, D.M., Moritz, C. Mable, B.K. (Eds.) Molecular Systematics (2nd ed.) 407-514, Sunderland, MA: Sinauer","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"","code":"# in real analysis use larger n, e.g. 500 preferably more if (FALSE) { data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree <- NJ(dm) fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit, TRUE) set.seed(6) tree <- rNNI(fit$tree, 1) fit <- update(fit, tree = tree) (res <- SOWH.test(fit, n=100)) summary(res) }"},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":null,"dir":"Reference","previous_headings":"","what":"Add tips to a tree — add.tips","title":"Add tips to a tree — add.tips","text":"function binds tips nodes phylogenetic trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add tips to a tree — add.tips","text":"","code":"add.tips(tree, tips, where, edge.length = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add tips to a tree — add.tips","text":"tree object class \"phylo\". tips character vector containing names tips. integer character vector length tips giving number node tip tree add new tips. edge.length optional numeric vector edge length","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add tips to a tree — add.tips","text":"object class phylo","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add tips to a tree — add.tips","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add tips to a tree — add.tips","text":"","code":"tree <- rcoal(10) plot(tree) nodelabels() tiplabels()  tree1 <- add.tips(tree, c(\"A\", \"B\", \"C\"), c(1,2,15)) plot(tree1)"},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare splits and add support values to an object — createLabel","title":"Compare splits and add support values to an object — createLabel","text":"Add support values splits, phylo networx object.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare splits and add support values to an object — createLabel","text":"","code":"createLabel(x, y, label_y, type = \"edge\", nomatch = NA)  addConfidences(x, y, ...)  # S3 method for phylo addConfidences(x, y, ...)  presenceAbsence(x, y)"},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare splits and add support values to an object — createLabel","text":"x object class splits, phylo networx y object class splits, phylo, multiPhylo networx label_y label y matched x. usually length(.splits(x)). type labels returned edges (networx) splits. nomatch default value match x y found. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare splits and add support values to an object — createLabel","text":"object x added bootstrap / MCMC support values.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compare splits and add support values to an object — createLabel","text":"Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol. 8, 1212--1220. doi:10.1111/2041-210X.12760","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare splits and add support values to an object — createLabel","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare splits and add support values to an object — createLabel","text":"","code":"data(woodmouse) woodmouse <- phyDat(woodmouse) tmpfile <- normalizePath(system.file(\"extdata/trees/RAxML_bootstrap.woodmouse\", package=\"phangorn\")) boot_trees <- read.tree(tmpfile)  dm <- dist.ml(woodmouse) tree <- upgma(dm) nnet <- neighborNet(dm)  tree <- addConfidences(tree, boot_trees) nnet <- addConfidences(nnet, boot_trees)  plot(tree, show.node.label=TRUE)  plot(nnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute all trees topologies. — allTrees","title":"Compute all trees topologies. — allTrees","text":"allTrees computes tree topologies rooted unrooted trees 10 tips. allTrees returns bifurcating trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute all trees topologies. — allTrees","text":"","code":"allTrees(n, rooted = FALSE, tip.label = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute all trees topologies. — allTrees","text":"n Number tips (<=10). rooted Rooted unrooted trees (default: rooted). tip.label Tip labels.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute all trees topologies. — allTrees","text":"object class multiPhylo.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute all trees topologies. — allTrees","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute all trees topologies. — allTrees","text":"","code":"trees <- allTrees(5)  old.par <- par(no.readonly = TRUE) par(mfrow = c(3,5)) for(i in 1:15)plot(trees[[i]])  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Ancestral character reconstruction. — ancestral.pml","title":"Ancestral character reconstruction. — ancestral.pml","text":"Marginal reconstruction ancestral character states.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ancestral character reconstruction. — ancestral.pml","text":"","code":"ancestral.pml(object, type = \"marginal\", return = \"prob\")  ancestral.pars(tree, data, type = c(\"MPR\", \"ACCTRAN\", \"POSTORDER\"),   cost = NULL, return = \"prob\")  pace(tree, data, type = c(\"MPR\", \"ACCTRAN\", \"POSTORDER\"), cost = NULL,   return = \"prob\")  plotAnc(tree, data, i = 1, site.pattern = TRUE, col = NULL,   cex.pie = par(\"cex\"), pos = \"bottomright\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ancestral character reconstruction. — ancestral.pml","text":"object object class pml type method used assign characters internal nodes, see details. return return phyDat object matrix probabilities. tree tree, .e. object class pml data object class phyDat cost cost matrix transitions two states. plots -th site pattern data. site.pattern logical, plot -th site pattern -th site col vector containing colors possible states. cex.pie numeric defining size pie graphs pos character string defining position legend ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ancestral character reconstruction. — ancestral.pml","text":"class \"phyDat\", containing ancestral states nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ancestral character reconstruction. — ancestral.pml","text":"argument \"type\" defines criterion assign internal nodes. ancestral.pml far \"ml\" (empirical) \"bayes\" ancestral.pars \"MPR\" \"ACCTRAN\" possible. parsimony reconstruction one keep mind often unique solution. details see vignette(\"Ancestral\").","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ancestral character reconstruction. — ancestral.pml","text":"Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Swofford, D.L., Maddison, W.P. (1987) Reconstructing ancestral character states Wagner parsimony. Math. Biosci. 87: 199--229 Yang, Z. (2006). Computational Molecular evolution. Oxford University Press, Oxford.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Ancestral character reconstruction. — ancestral.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ancestral character reconstruction. — ancestral.pml","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  fit <- pml(tree, Laurasiatherian) anc.ml <- ancestral.pml(fit, type = \"ml\") anc.p <- ancestral.pars(tree, Laurasiatherian) if (FALSE) { require(seqLogo) seqLogo( t(subset(anc.ml, 48, 1:20)[[1]]), ic.scale=FALSE) seqLogo( t(subset(anc.p, 48, 1:20)[[1]]), ic.scale=FALSE) } # plot the first site pattern plotAnc(tree, anc.ml, 1)  # plot the third character plotAnc(tree, anc.ml, attr(anc.ml, \"index\")[3])"},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion among phylogenetic network objects — as.networx","title":"Conversion among phylogenetic network objects — as.networx","text":".networx convert splits objects networx object. important exists generic plot function plot phylogenetic network split graphs.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion among phylogenetic network objects — as.networx","text":"","code":"as.networx(x, ...)  # S3 method for splits as.networx(x, planar = FALSE, coord = \"none\", ...)  # S3 method for phylo as.networx(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion among phylogenetic network objects — as.networx","text":"x object class \"splits\" \"phylo\" ... arguments passed methods. planar logical whether produce planar graph cyclic splits (may excludes splits). coord add coordinates nodes, allows reproduce plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conversion among phylogenetic network objects — as.networx","text":"networx object hold information phylogenetic network extends phylo object. Therefore generic function phylo objects also work networx objects.  argument planar = TRUE create planar split graph based cyclic ordering. objects can nicely plotted \"2D\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Conversion among phylogenetic network objects — as.networx","text":"internal representation likely change.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Conversion among phylogenetic network objects — as.networx","text":"Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol. 8, 1212--1220. doi:10.1111/2041-210X.12760","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conversion among phylogenetic network objects — as.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion among phylogenetic network objects — as.networx","text":"","code":"set.seed(1) tree1 <- rtree(20, rooted=FALSE) sp <- as.splits(rNNI(tree1, n=10)) net <- as.networx(sp) plot(net)  if (FALSE) { # also see example in consensusNet example(consensusNet) }"},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion among Sequence Formats — phyDat","title":"Conversion among Sequence Formats — phyDat","text":"functions transform several DNA formats phyDat format. allSitePattern generates alignment possible site patterns.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion among Sequence Formats — phyDat","text":"","code":"phyDat(data, type = \"DNA\", levels = NULL, return.index = TRUE, ...)  as.phyDat(x, ...)  # S3 method for factor as.phyDat(x, ...)  # S3 method for DNAbin as.phyDat(x, ...)  # S3 method for alignment as.phyDat(x, type = \"DNA\", ...)  phyDat2alignment(x)  # S3 method for MultipleAlignment as.phyDat(x, ...)  # S3 method for phyDat as.MultipleAlignment(x, ...)  # S3 method for phyDat as.character(x, allLevels = TRUE, ...)  # S3 method for phyDat as.data.frame(x, ...)  # S3 method for phyDat as.DNAbin(x, ...)  # S3 method for phyDat as.AAbin(x, ...)  genlight2phyDat(x, ambiguity = NA)  acgt2ry(obj)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion among Sequence Formats — phyDat","text":"data object containing sequences. type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). levels Level attributes. return.index TRUE returns index site patterns. ... arguments passed methods. x object containing sequences. allLevels return original data. ambiguity character ambiguous character contrast provided. obj object class phyDat","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conversion among Sequence Formats — phyDat","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conversion among Sequence Formats — phyDat","text":"type \"USER\" vector give levels. example c(\"\", \"c\", \"g\", \"t\", \"-\") create data object can used phylogenetic analysis gaps fifth state.  detailed example specifying \"USER\" defined data formats vignette \"phangorn-specials\". acgt2ry converts phyDat object nucleotides binary ry-coded dataset.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conversion among Sequence Formats — phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion among Sequence Formats — phyDat","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # transform as characters LauraChar <- as.character(Laurasiatherian) # and back Laura <- phyDat(LauraChar) all.equal(Laurasiatherian, Laura) #> [1] TRUE LauraDNAbin <- as.DNAbin(Laurasiatherian) all.equal(Laurasiatherian, as.phyDat(LauraDNAbin)) #> [1] TRUE"},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Splits representation of graphs and trees. — allSplits","title":"Splits representation of graphs and trees. — allSplits","text":".splits produces list splits bipartitions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splits representation of graphs and trees. — allSplits","text":"","code":"allSplits(k, labels = NULL)  allCircularSplits(k, labels = NULL)  as.splits(x, ...)  # S3 method for splits as.matrix(x, zero.print = 0L, one.print = 1L, ...)  # S3 method for splits as.Matrix(x, ...)  # S3 method for splits print(x, maxp = getOption(\"max.print\"), zero.print = \".\",   one.print = \"|\", ...)  # S3 method for splits c(..., recursive = FALSE)  # S3 method for splits unique(x, incomparables = FALSE, unrooted = TRUE, ...)  # S3 method for phylo as.splits(x, ...)  # S3 method for multiPhylo as.splits(x, ...)  # S3 method for networx as.splits(x, ...)  # S3 method for splits as.prop.part(x, ...)  # S3 method for splits as.bitsplits(x)  # S3 method for bitsplits as.splits(x, ...)  compatible(obj1, obj2 = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splits representation of graphs and trees. — allSplits","text":"k number taxa. labels names taxa. x object class phylo multiPhylo. ... arguments passed methods. zero.print character printed zeros. one.print character printed ones. maxp integer, default options(max.print), influences many entries large matrices printed . recursive logical. recursive = TRUE, function recursively descends lists (pairlists) combining elements vector. incomparables compatibility far. unrooted todo. obj1, obj2 object class splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splits representation of graphs and trees. — allSplits","text":".splits returns object class splits, mainly list splits attributes. Often splits object contain attributes confidences bootstrap Bayesian support values weight storing edge weights. compatible return lower triangular matrix 1 indicates two splits incompatible.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Splits representation of graphs and trees. — allSplits","text":"internal representation likely change.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Splits representation of graphs and trees. — allSplits","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splits representation of graphs and trees. — allSplits","text":"","code":"(sp <- as.splits(rtree(5))) #>       t4 t5 t1 t3 t2 #>  [1,]  |  .  .  .  . #>  [2,]  .  |  .  .  . #>  [3,]  .  .  |  .  . #>  [4,]  .  .  .  |  . #>  [5,]  .  .  .  .  | #>  [6,]  |  |  |  |  | #>  [7,]  |  |  .  .  . #>  [8,]  .  .  |  |  | #>  [9,]  .  .  .  |  | write.nexus.splits(sp) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.9.0.9000 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=5; #> \tTAXLABELS t4 t5 t1 t3 t2 ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=5 nsplits=8; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.478118034312502 \t1, #> \t\t2\t0.924074469832703 \t1 3 4 5, #> \t\t3\t0.976170694921166 \t1 2 4 5, #> \t\t4\t0.356726912083104 \t1 2 3 5, #> \t\t5\t0.431473690550774 \t1 2 3 4, #> \t\t6\t0.129372348077595 \t1 2, #> \t\t7\t0.59876096714288 \t1 2, #> \t\t8\t0.731792511884123 \t1 2 3, #> \t; #> END; spl <- allCircularSplits(5) plot(as.networx(spl))"},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch and bound for finding all most parsimonious trees — bab","title":"Branch and bound for finding all most parsimonious trees — bab","text":"bab finds parsimonious trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch and bound for finding all most parsimonious trees — bab","text":"","code":"bab(data, tree = NULL, trace = 1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch and bound for finding all most parsimonious trees — bab","text":"data object class phyDat. tree phylogenetic tree object class phylo, otherwise pratchet search performed. trace defines much information printed optimization. ... arguments passed methods","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch and bound for finding all most parsimonious trees — bab","text":"bab returns parsimonious trees object class multiPhylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Branch and bound for finding all most parsimonious trees — bab","text":"implementation slow depending data may take long time. worst case (2n-5)!! possible trees examined, n number species / tips. 10 species already 2027025 tip-labelled unrooted trees. uses basic strategies find lower upper bounds similar penny phylip. bab uses basic heuristic approach MinMax Squeeze (Holland et al. 2005) improve lower bound.  positive side bab like many implementations restricted binary nucleotide data.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Branch and bound for finding all most parsimonious trees — bab","text":"Hendy, M.D. Penny D. (1982) Branch bound algorithms determine minimal evolutionary trees.  Math. Biosc. 59, 277-290 Holland, B.R., Huber, K.T. Penny, D. Moulton, V. (2005) MinMax Squeeze: Guaranteeing Minimal Tree Population Data, Molecular Biology Evolution, 22, 235--242 White, W.T. Holland, B.R. (2011) Faster exact maximum parsimony search XMP. Bioinformatics, 27(10),1359--1367","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Branch and bound for finding all most parsimonious trees — bab","text":"Klaus Schliep klaus.schliep@gmail.com based work Liam Revell","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch and bound for finding all most parsimonious trees — bab","text":"","code":"data(yeast) dfactorial(11) #> [1] 10395 # choose only the first two genes gene12 <- yeast[, 1:3158] trees <- bab(gene12)"},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries of alignments — baseFreq","title":"Summaries of alignments — baseFreq","text":"baseFreq computes frequencies (absolute relative) states sample sequences. glance computes useful information alignment.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries of alignments — baseFreq","text":"","code":"baseFreq(obj, freq = FALSE, all = FALSE, drop.unused.levels = FALSE)  # S3 method for phyDat glance(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries of alignments — baseFreq","text":"obj, x object class phyDat freq logical, 'TRUE', frequencies counts returned otherwise proportions logical; = TRUE, counts bases, ambiguous codes, missing data, alignment gaps returned defined contrast. drop.unused.levels logical, drop unused levels ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summaries of alignments — baseFreq","text":"baseFreq returna named vector glance one row data.frame.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summaries of alignments — baseFreq","text":"Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries of alignments — baseFreq","text":"","code":"data(Laurasiatherian) data(chloroplast) # base frequencies baseFreq(Laurasiatherian) #>         a         c         g         t  #> 0.3321866 0.1990791 0.2040652 0.2646691  baseFreq(Laurasiatherian, all=TRUE) #>         a         c         g         t         u         m         r         w  #> 0.3321866 0.1990791 0.2040652 0.2646691 0.0000000 0.0000000 0.0000000 0.0000000  #>         s         y         k         v         h         d         b         n  #> 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000  #>         ?         -  #> 0.0000000 0.0000000  baseFreq(Laurasiatherian, freq=TRUE) #>     a     c     g     t  #> 49633 29745 30490 39545  baseFreq(chloroplast) #>           a           r           n           d           c           q  #> 0.086702955 0.051669804 0.036230253 0.040435459 0.006650569 0.039678317  #>           e           g           h           i           l           k  #> 0.046635835 0.090775149 0.029395514 0.073585987 0.101712777 0.040148973  #>           m           f           p           s           t           w  #> 0.024852664 0.051260539 0.048109192 0.054176557 0.051618646 0.021905951  #>           y           v  #> 0.031636245 0.072818613  glance(Laurasiatherian) #>   nseq nchar unique_site_pattern parsimony_informative_sites const_sites #> 1   47  3179                1605                        1400        1354 glance(chloroplast) #>   nseq nchar unique_site_pattern parsimony_informative_sites const_sites #> 1   19  5144                2775                        2032        2190"},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap — bootstrap.pml","title":"Bootstrap — bootstrap.pml","text":"bootstrap.pml performs (non-parametric) bootstrap analysis bootstrap.phyDat produces list bootstrapped data sets. plotBS plots phylogenetic tree bootstrap values assigned (internal) edges.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap — bootstrap.pml","text":"","code":"bootstrap.pml(x, bs = 100, trees = TRUE, multicore = FALSE,   mc.cores = NULL, ...)  bootstrap.phyDat(x, FUN, bs = 100, multicore = FALSE, mc.cores = NULL,   jumble = TRUE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap — bootstrap.pml","text":"x object class pml phyDat. bs number bootstrap samples. trees return trees (default) whole pml objects. multicore logical, whether models estimated parallel. mc.cores number cores use bootstrap. supported UNIX-alike systems. ... parameters used optim.pml plot.phylo. FUN function estimate trees. jumble logical, jumble order sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap — bootstrap.pml","text":"bootstrap.pml returns object class multi.phylo list element object class pml. plotBS returns silently tree, .e. object class phylo bootstrap values node labels. argument BStrees optional supplied tree labels supplied node.label slot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap — bootstrap.pml","text":"possible bootstrap performed parallel, help multicore package. Unfortunately multicore package work windows GUI interfaces (\"aqua\" mac). However speed nicely command line (\"X11\").","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrap — bootstrap.pml","text":"Felsenstein J. (1985) Confidence limits phylogenies. approach using bootstrap. Evolution 39, 783--791 Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D., De Oliveira, T., & Gascuel, O. (2018). Renewing Felsenstein’s phylogenetic bootstrap era big data. Nature, 556(7702), 452--456. Penny D. Hendy M.D. (1985) Testing methods evolutionary tree construction. Cladistics 1, 266--278 Penny D. Hendy M.D. (1986) Estimating reliability evolutionary trees. Molecular Biology Evolution 3, 403--417","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bootstrap — bootstrap.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap — bootstrap.pml","text":"","code":"if (FALSE) { data(Laurasiatherian) dm <- dist.hamming(Laurasiatherian) tree <- NJ(dm) # NJ set.seed(123) NJtrees <- bootstrap.phyDat(Laurasiatherian,      FUN=function(x)NJ(dist.hamming(x)), bs=100) treeNJ <- plotBS(tree, NJtrees, \"phylogram\")  # Maximum likelihood fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit, rearrangement=\"NNI\") set.seed(123) bs <- bootstrap.pml(fit, bs=100, optNni=TRUE) treeBS <- plotBS(fit$tree,bs)  # Maximum parsimony treeMP <- pratchet(Laurasiatherian) treeMP <- acctran(treeMP, Laurasiatherian) set.seed(123) BStrees <- bootstrap.phyDat(Laurasiatherian, pratchet, bs = 100) treeMP <- plotBS(treeMP, BStrees, \"phylogram\") add.scale.bar()  # export tree with bootstrap values as node labels # write.tree(treeBS) }"},{"path":"https://klausvigo.github.io/phangorn/reference/chloroplast.html","id":null,"dir":"Reference","previous_headings":"","what":"Chloroplast alignment — chloroplast","title":"Chloroplast alignment — chloroplast","text":"Amino acid alignment 15 genes 19 different chloroplast.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/chloroplast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chloroplast alignment — chloroplast","text":"","code":"data(chloroplast) chloroplast #> 19 sequences with 5144 character and 2775 different site patterns. #> The states are a r n d c q e g h i l k m f p s t w y v"},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to plot.phylo — cladePar","title":"Utility function to plot.phylo — cladePar","text":"cladePar can help coloring (choosing edge width/type) clades.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to plot.phylo — cladePar","text":"","code":"cladePar(tree, node, edge.color = \"red\", tip.color = edge.color,   edge.width = 1, edge.lty = \"solid\", x = NULL, plot = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to plot.phylo — cladePar","text":"tree object class phylo. node node common ancestor clade. edge.color see plot.phylo. tip.color see plot.phylo. edge.width see plot.phylo. edge.lty see plot.phylo. x result previous call cladeInfo. plot logical, TRUE tree plotted. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to plot.phylo — cladePar","text":"list containing information edges tips.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utility function to plot.phylo — cladePar","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function to plot.phylo — cladePar","text":"","code":"tree <- rtree(10) plot(tree) nodelabels()  x <- cladePar(tree, 12) cladePar(tree, 18, \"blue\", \"blue\", x=x, plot=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Species Tree — coalSpeciesTree","title":"Species Tree — coalSpeciesTree","text":"coalSpeciesTree estimates species trees can handle multiple individuals per species.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Species Tree — coalSpeciesTree","text":"","code":"coalSpeciesTree(tree, X = NULL, sTree = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Species Tree — coalSpeciesTree","text":"tree object class multiPhylo X phyDat object define individual belongs species. sTree species tree fixes topology.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Species Tree — coalSpeciesTree","text":"function returns object class phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Species Tree — coalSpeciesTree","text":"coalSpeciesTree estimates single linkage tree suggested Liu et al. (2010) element wise minima cophenetic matrices gene trees. extends speciesTree ape allows several individuals per gene tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Species Tree — coalSpeciesTree","text":"Liu, L., Yu, L. Pearl, D. K. (2010) Maximum tree: consistent estimator species tree. Journal Mathematical Biology, 60, 95--106.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Species Tree — coalSpeciesTree","text":"Klaus Schliep klaus.schliep@gmail.com Emmanuel Paradies","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":null,"dir":"Reference","previous_headings":"","what":"codonTest — codonTest","title":"codonTest — codonTest","text":"Models detecting positive selection","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"codonTest — codonTest","text":"","code":"codonTest(tree, object, model = c(\"M0\", \"M1a\", \"M2a\"),   frequencies = \"F3x4\", opt_freq = FALSE, codonstart = 1,   control = pml.control(maxit = 20), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"codonTest — codonTest","text":"tree phylogenetic tree. object object class phyDat. model vector containing substitution models compare \"\" test available models. frequencies character string vector defining compute codon frequencies opt_freq optimize frequencies (far ignored) codonstart integer giving start translation. 1, 2, 3, larger values accepted effect start translation within sequence. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"codonTest — codonTest","text":"list element called summary containing data.frame log-likelihood, number estimated parameters, etc. tested models. object called posterior contains posterior probability rate class sites estimates defined models.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"codonTest — codonTest","text":"codonTest allows test positive selection similar programs like PAML (Yang ) HyPhy (Kosakovsky Pond et al. 2005). several options deriving codon frequencies. Frequencies can \"equal\" (1/61), derived nucleotide frequencies \"F1x4\" \"F3x4\" \"empirical\" codon frequencies. frequencies taken using empirical frequencies estimated via maximum likelihood. far M0 model (Goldman Yang 2002), M1a M2a implemented. M0 model always computed optional. convergence may slow sometimes fails.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"codonTest — codonTest","text":"Ziheng Yang (2014). Molecular Evolution: Statistical Approach. Oxford University Press, Oxford Sergei L. Kosakovsky Pond, Simon D. W. Frost, Spencer V. Muse (2005) HyPhy: hypothesis testing using phylogenies, Bioinformatics, 21(5): 676--679, doi:10.1093/bioinformatics/bti079 Nielsen, R., Z. Yang. (1998) Likelihood models detecting positively selected amino acid sites applications HIV-1 envelope gene. Genetics, 148: 929--936","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"codonTest — codonTest","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"codonTest — codonTest","text":"","code":"if (FALSE) { # load woodmouse data from ape data(woodmouse) dat_codon <- dna2codon(as.phyDat(woodmouse)) tree <- NJ(dist.ml(dat_codon)) # optimize the model the old way fit <- pml(tree, dat_codon, bf=\"F3x4\") M0 <- optim.pml(fit, model=\"codon1\") # Now using the codonTest function fit_codon <- codonTest(tree, dat_codon) fit_codon plot(fit_codon, \"M1a\") }"},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"Computes consensusNetwork, .e. object class networx list trees, .e. class class multiPhylo. Computes networx object collection splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"","code":"consensusNet(obj, prob = 0.3, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"obj object class multiPhylo. prob proportion split present trees represented network. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"consensusNet returns object class networx.  just intermediate plot phylogenetic networks igraph.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"Holland B.R., Huber K.T., Moulton V., Lockhart P.J. (2004) Using consensus networks visualize contradictory evidence species phylogeny. Molecular Biology Evolution, 21, 1459--61","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes a consensusNetwork from a list of trees Computes a networx\nobject from a collection of splits. — consensusNet","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian, FUN = function(x)nj(dist.hamming(x)),     bs=50) cnet <- consensusNet(bs, .3) plot(cnet)  if (FALSE) { library(rgl) open3d() plot(cnet, type = \"3D\", show.tip.label=FALSE, show.nodes=TRUE) plot(cnet, type = \"equal angle\", show.edge.label=TRUE)  tmpfile <- normalizePath(system.file(\"extdata/trees/RAxML_bootstrap.woodmouse\", package=\"phangorn\")) trees <- read.tree(tmpfile) cnet_woodmouse <- consensusNet(trees, .3) plot(cnet_woodmouse, type = \"equal angle\", show.edge.label=TRUE) }"},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"cophenetic.networx computes pairwise distances pairs tips phylogenetic network using branch lengths.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"","code":"# S3 method for networx cophenetic(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"x object class networx.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"object class dist, names set according tip labels (given element tip.label argument x).","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the \\(\\delta\\) score — delta.score","title":"Computes the \\(\\delta\\) score — delta.score","text":"Computes treelikeness","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the \\(\\delta\\) score — delta.score","text":"","code":"delta.score(x, arg = \"mean\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the \\(\\delta\\) score — delta.score","text":"x object class phyDat arg Specifies return value, one \"\", \"mean\" \"sd\" ... arguments passed dist.hamming","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the \\(\\delta\\) score — delta.score","text":"vector containing \\(\\delta\\) scores.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes the \\(\\delta\\) score — delta.score","text":"BR Holland, KT Huber, Dress, V Moulton (2002) \\(\\delta\\) Plots: tool analyzing phylogenetic distance data Russell D. Gray, David Bryant, Simon J. Greenhill (2010) shape fabric human history Molecular Biology Evolution, 19(12) 2051--2059 Russell D. Gray, David Bryant, Simon J. Greenhill (2010) shape fabric human history Phil. Trans. R. Soc. B, 365 3923--3933; DOI: 10.1098/rstb.2010.0162","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes the \\(\\delta\\) score — delta.score","text":"Alastair Potts Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the \\(\\delta\\) score — delta.score","text":"","code":"data(yeast) hist(delta.score(yeast, \"all\"))"},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a densiTree. — densiTree","title":"Plots a densiTree. — densiTree","text":"R function plot trees similar produced DensiTree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a densiTree. — densiTree","text":"","code":"densiTree(x, type = \"cladogram\", alpha = 1/length(x), consensus = NULL,   direction = \"rightwards\", optim = FALSE, scaleX = FALSE, col = 1,   width = 1, lty = 1, cex = 0.8, font = 3, tip.color = 1, adj = 0,   srt = 0, underscore = FALSE, label.offset = 0, scale.bar = TRUE,   jitter = list(amount = 0, random = TRUE), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a densiTree. — densiTree","text":"x object class multiPhylo. type character string specifying type phylogeny, far \"cladogram\" (default) \"phylogram\" supported. alpha parameter semi-transparent colors. consensus tree character vector used define order tip labels. direction character string specifying direction tree. Four values possible: \"rightwards\" (default), \"leftwards\", \"upwards\", \"downwards\". optim yet used. scaleX scale trees identical heights. col scalar vector giving colours used draw edges plotted phylogeny. taken order input trees x. fewer colours given number trees, colours recycled. width edge width. lty line type. cex numeric value giving factor scaling tip labels. font integer specifying type font labels: 1 (plain text), 2 (bold), 3 (italic, default), 4 (bold italic). tip.color color tip labels. adj numeric specifying justification text strings labels: 0 (left-justification), 0.5 (centering), 1 (right-justification). srt numeric giving much labels rotated degrees. underscore logical specifying whether underscores tip labels written spaces (default) left (TRUE). label.offset numeric giving space nodes tips phylogeny corresponding labels. scale.bar logical specifying whether add scale.bar plot. jitter allows shift trees. list two arguments: amount jitter random equally spaced (see details ) ... arguments passed plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots a densiTree. — densiTree","text":"consensus tree provided densiTree computes consensus tree, input trees different labels mrp.supertree backbone. avoid many unnecessary crossings edges. Trees rooted, wise output may visually pleasing. jitter shifts trees bit exactly top . amount == 0, ignored. random=TRUE result permutation runif(n, -amount, amount), otherwise seq(-amount, amount, length=n), n <- length(x).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plots a densiTree. — densiTree","text":"densiTree inspired great DensiTree program Remco Bouckaert. Remco R. Bouckaert (2010) DensiTree: making sense sets phylogenetic trees Bioinformatics, 26 (10), 1372-1373.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots a densiTree. — densiTree","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a densiTree. — densiTree","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian, FUN =    function(x) upgma(dist.hamming(x)), bs=25) # cladogram nice to show topological differences densiTree(bs, type=\"cladogram\", col=\"blue\")   densiTree(bs, type=\"phylogram\", col=\"green\", direction=\"downwards\", width=2)   # plot five trees slightly shifted, no transparent color densiTree(bs[1:5], type=\"phylogram\", col=1:5, width=2, jitter=     list(amount=.3, random=FALSE), alpha=1)   if (FALSE) { # phylograms are nice to show different age estimates require(PhyloOrchard) data(BinindaEmondsEtAl2007) BinindaEmondsEtAl2007 <- .compressTipLabel(BinindaEmondsEtAl2007) densiTree(BinindaEmondsEtAl2007, type=\"phylogram\", col=\"red\") }"},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a design matrix or non-negative LS — designTree","title":"Compute a design matrix or non-negative LS — designTree","text":"nnls.tree estimates branch length using non-negative least squares given tree distance matrix.  designTree designSplits compute design matrices estimation edge length (phylogenetic) trees using linear models.  larger trees sparse design matrix can save lot memory.  computes contrast matrix method \"rooted\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a design matrix or non-negative LS — designTree","text":"","code":"designTree(tree, method = \"unrooted\", sparse = FALSE, tip.dates = NULL,   ...)  nnls.tree(dm, tree, method = c(\"unrooted\", \"ultrametric\", \"tipdated\"),   trace = 1, weight = NULL, balanced = FALSE, tip.dates = NULL)  nnls.phylo(x, dm, method = \"unrooted\", trace = 0, ...)  nnls.splits(x, dm, trace = 0)  nnls.networx(x, dm)  designSplits(x, splits = \"all\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a design matrix or non-negative LS — designTree","text":"tree object class phylo method compute \"unrooted\", \"ultrametric\" \"tipdated\" tree. sparse return sparse design matrix. tip.dates vector sampling times associated tips tree. ... arguments, passed methods. dm distance matrix. trace defines much information printed optimization. weight vector weights used fitting process. Weighted least squares used weights w, .e., sum(w * e^2) minimized. balanced use weights balanced fastME x number taxa. splits one \"\", \"star\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a design matrix or non-negative LS — designTree","text":"nnls.tree return tree, .e. object class phylo.  designTree designSplits matrix, possibly sparse.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute a design matrix or non-negative LS — designTree","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a design matrix or non-negative LS — designTree","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  dm <-  as.matrix(dm) y <- dm[lower.tri(dm)] X <- designTree(tree) lm(y~X-1) #>  #> Call: #> lm(formula = y ~ X - 1) #>  #> Coefficients: #>   X89<->36    X89<->37    X77<->35    X77<->38    X73<->33    X73<->34   #>  0.0499157   0.0491439   0.0724626   0.0755455   0.0712616   0.0725432   #>   X65<->73    X65<->77    X51<->65    X51<->89    X75<->10    X75<->11   #>  0.0034694   0.0099328   0.0029426   0.0432799   0.0885305   0.0820387   #>   X62<->12    X62<->13    X86<->15    X86<->16    X67<->14    X67<->17   #>  0.0461128   0.0479378   0.0134025   0.0151296   0.0467324   0.0580930   #>   X63<->67    X63<->86    X59<->63    X59<->18    X88<->45    X88<->47   #>  0.0035646   0.0360953   0.0032091   0.0775894   0.0034977   0.0063178   #>   X80<->88    X80<->46    X74<->80    X74<->44    X72<->74    X72<->43   #>  0.0231875   0.0381300   0.0154870   0.0421651   0.0015801   0.0392256   #>   X85<->19    X85<->20    X79<->21    X79<->22    X71<->79    X71<->85   #>  0.0088520   0.0092959   0.0229321   0.0224528   0.0145614   0.0299323   #>   X81<->25    X81<->26    X87<->28    X87<->29    X82<->87    X82<->30   #>  0.0274720   0.0286839   0.0148471   0.0117270   0.0181692   0.0364881   #>   X70<->82    X70<->27    X68<->70    X68<->24    X66<->68    X66<->81   #>  0.0219311   0.0563100   0.0033377   0.0569549   0.0008004   0.0221615   #>   X61<->66    X61<->23    X60<->61    X60<->71    X58<->60    X58<->72   #>  0.0021831   0.0502453   0.0042762   0.0102058   0.0020978   0.0117101   #>   X57<->58    X57<->59    X56<->57    X56<->62    X53<->56    X53<->75   #>  0.0013537   0.0043899   0.0011632   0.0063020   0.0070446   0.0117666   #>   X84<->39    X84<->40    X78<->84    X78<->42    X52<->78    X52<->41   #>  0.0696111   0.0583581   0.0144780   0.0701359   0.0225117   0.0792075   #>   X50<->52    X50<->53    X49<->50    X49<->51     X92<->2     X92<->3   #>  0.0008563   0.0018880   0.0036910   0.0033483   0.0324915   0.0274029   #>   X91<->92     X91<->4    X90<->91     X90<->5    X83<->90     X83<->1   #>  0.0090135   0.0362511   0.0024394   0.0505988   0.0425011   0.1170301   #>   X69<->83     X69<->9     X64<->7     X64<->8    X55<->64     X55<->6   #>  0.0289009   0.0967237   0.1091965   0.0693124   0.0029756   0.0874519   #>   X54<->55    X54<->69    X76<->31    X76<->32    X48<->76    X48<->54   #>  0.0027613   0.0065884   0.0534621   0.0681912   0.0151764   0.0010911   #>   X48<->49   #> -0.0018629   #>  # avoids negative edge weights tree2 <- nnls.tree(dm, tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Operators — ldfactorial","title":"Arithmetic Operators — ldfactorial","text":"double factorial function","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Operators — ldfactorial","text":"","code":"ldfactorial(x)  dfactorial(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Operators — ldfactorial","text":"x numeric scalar vector","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Operators — ldfactorial","text":"dfactorial(x) returns double factorial, \\(x\\!\\! = 1 * 3 * 5 * \\ldots * x \\) ldfactorial(x) natural logarithm .","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic Operators — ldfactorial","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Operators — ldfactorial","text":"","code":"dfactorial(1:10) #>  [1]    1.000000    1.595769    3.000000    6.383076   15.000000   38.298459 #>  [7]  105.000000  306.387671  945.000000 3063.876713"},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete Gamma and Beta distribution — discrete.gamma","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"discrete.gamma internally used likelihood computations pml optim.pml. useful understand works simulation studies cases .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"","code":"discrete.gamma(alpha, k)  discrete.beta(shape1, shape2, k)  plot_gamma_plus_inv(shape = 1, inv = 0, k = 4, discrete = TRUE,   cdf = TRUE, append = FALSE, xlab = \"x\", ylab = ifelse(cdf, \"F(x)\",   \"f(x)\"), xlim = NULL, verticals = FALSE, edge.length = NULL,   site.rate = \"gamma\", ...)  plotRates(obj, cdf.color = \"blue\", main = \"cdf\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"alpha Shape parameter gamma distribution. k Number intervals discrete gamma distribution. shape1, shape2 non-negative parameters Beta distribution. shape Shape parameter gamma distribution. inv Proportion invariable sites. discrete logical whether plot discrete (default) continuous pdf cdf. cdf logical whether plot cumulative distribution function density / probability function. append logical; TRUE add existing plot. xlab label x axis, defaults description x. ylab label y axis, defaults description y. xlim x limits plot. verticals logical; TRUE, draw vertical lines steps. edge.length Total edge length (sum edges tree). site.rate Indicates type gamma distribution use. Options \"gamma\" (Yang 1994) \"gamma_quadrature\" using Laguerre quadrature approach Felsenstein (2001) ... arguments passed methods. obj object class pml cdf.color color cdf. main main title plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"discrete.gamma returns matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"functions exported used different packages far package coalescentMCMC, intended end user. functions call C code far less forgiving import expect pml.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"","code":"discrete.gamma(1, 4) #> [1] 0.1369538 0.4767519 1.0000000 2.3862944  old.par <- par(no.readonly = TRUE) par(mfrow = c(2,1)) plot_gamma_plus_inv(shape=2, discrete = FALSE, cdf=FALSE) plot_gamma_plus_inv(shape=2, append = TRUE, cdf=FALSE)  plot_gamma_plus_inv(shape=2, discrete = FALSE) plot_gamma_plus_inv(shape=2, append = TRUE)  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Distances from Sequences — dist.hamming","title":"Pairwise Distances from Sequences — dist.hamming","text":"dist.hamming, dist.ml dist.logDet compute pairwise distances object class phyDat.  dist.ml uses DNA / AA sequences compute distances different substitution models.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Distances from Sequences — dist.hamming","text":"","code":"dist.hamming(x, ratio = TRUE, exclude = \"none\")  dist.ml(x, model = \"JC69\", exclude = \"none\", bf = NULL, Q = NULL,   k = 1L, shape = 1, ...)  dist.logDet(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Distances from Sequences — dist.hamming","text":"x object class phyDat ratio Compute uncorrected ('p') distance character difference. exclude One \"none\", \"\", \"pairwise\" indicating whether delete sites missing data (ambiguous states). default handle missing data pml. model One \"JC69\", \"F81\" one 17 amino acid models see details. bf vector base frequencies. Q vector containing lower triangular part rate matrix. k Number intervals discrete gamma distribution. shape Shape parameter gamma distribution. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Distances from Sequences — dist.hamming","text":"object class dist","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Distances from Sequences — dist.hamming","text":"far 17 amino acid models supported (\"WAG\", \"JTT\", \"LG\", \"Dayhoff\", \"cpREV\", \"mtmam\", \"mtArt\", \"MtZoa\", \"mtREV24\", \"VT\",\"RtREV\", \"HIVw\", \"HIVb\", \"FLU\", \"Blosum62\", \"Dayhoff_DCMut\" \"JTT_DCMut\") additional rate matrices frequencies can supplied. \"F81\" model uses empirical base frequencies, \"JC69\" equal base frequencies. even case data nucleotides.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pairwise Distances from Sequences — dist.hamming","text":"Lockhart, P. J., Steel, M. ., Hendy, M. D. Penny, D. (1994) Recovering evolutionary trees realistic model sequence evolution. Molecular Biology Evolution, 11, 605--602. Jukes TH Cantor CR (1969). Evolution Protein Molecules. New York: Academic Press. 21--132. McGuire, G., Prentice, M. J. Wright, F. (1999). Improved error bounds genetic distances DNA sequences. Biometrics, 55, 1064–1070.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Distances from Sequences — dist.hamming","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Distances from Sequences — dist.hamming","text":"","code":"data(Laurasiatherian) dm1 <- dist.hamming(Laurasiatherian) tree1 <- NJ(dm1) dm2 <- dist.logDet(Laurasiatherian) tree2 <- NJ(dm2) treedist(tree1,tree2) #>      symmetric.difference   branch.score.difference           path.difference  #>                4.00000000                0.05705091               30.95157508  #> quadratic.path.difference  #>                0.80097967  # JC model dm3 <- dist.ml(Laurasiatherian) tree3 <- NJ(dm3) treedist(tree1,tree3) #>      symmetric.difference   branch.score.difference           path.difference  #>                 6.0000000                 0.0412520                30.3644529  #> quadratic.path.difference  #>                 0.6106899  # F81 + Gamma dm4 <- dist.ml(Laurasiatherian, model=\"F81\", k=4, shape=.4) tree4 <- NJ(dm4) treedist(tree1,tree4) #>      symmetric.difference   branch.score.difference           path.difference  #>                12.0000000                 0.1356107                40.7676342  #> quadratic.path.difference  #>                 2.0709714  treedist(tree3,tree4) #>      symmetric.difference   branch.score.difference           path.difference  #>                8.00000000                0.09494752               39.52214569  #> quadratic.path.difference  #>                1.46345381"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"function computes matrix pairwise uncorrected polymorphism p-distances. Polymorphism p-distances include intra-individual site polymorphisms (2ISPs; e.g. \"R\") calculating genetic distances.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"","code":"dist.p(x, cost = \"polymorphism\", ignore.indels = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"x matrix containing DNA sequences; must class \"phyDat\" (use .phyDat convert DNAbin objects). cost cost matrix \"polymorphism\" predefined one. ignore.indels logical indicating whether gaps treated fifth state . Warning, gap site treated characters, indel spans number base positions treated multiple character states.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"object class dist.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"polymorphism p-distances (Potts et al. 2014) developed analyse intra-individual variant polymorphism. example, widely used ribosomal internal transcribed spacer () region (e.g. Alvarez Wendel, 2003) consists 100's 1000's units within array across potentially multiple nucleolus organizing regions (Bailey et al., 2003; Goeker Grimm, 2008). can give rise intra-individual site polymorphisms (2ISPs) can detected direct-PCR sequencing cloning . Clone consensus sequences (see Goeker Grimm, 2008) can analysed function.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"Alvarez, ., J. F. Wendel. (2003) Ribosomal sequences plant phylogenetic inference.  Molecular Phylogenetics Evolution, 29, 417--434. Bailey, C. D., T. G. Carr, S. . Harris, C. E. Hughes. (2003) Characterization angiosperm nrDNA polymorphism, paralogy, pseudogenes. Molecular Phylogenetics Evolution 29, 435--455. Goeker, M., G. Grimm. (2008) General functions transform associate data host data, use phylogenetic inference sequences intra-individual variability. BMC Evolutionary Biology, 8:86. Potts, .J., T.. Hedderson, G.W. Grimm. (2014) Constructing phylogenies presence intra-individual site polymorphisms (2ISPs) focus nuclear ribosomal cistron. Systematic Biology, 63, 1--16","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"Klaus Schliep Alastair Potts","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"","code":"data(Laurasiatherian) laura <- as.DNAbin(Laurasiatherian)  dm <- dist.p(Laurasiatherian, \"polymorphism\")  ######################################################## # Dealing with indel 2ISPs # These can be coded using an \"x\" in the alignment. Note # that as.character usage in the read.dna() function. ######################################################### cat(\"3 5\",     \"No305     ATRA-\",     \"No304     ATAYX\",     \"No306     ATAGA\",     file = \"exdna.txt\", sep = \"\\n\") (ex.dna <- read.dna(\"exdna.txt\", format = \"sequential\", as.character=TRUE)) #>       [,1] [,2] [,3] [,4] [,5] #> No305 \"a\"  \"t\"  \"r\"  \"a\"  \"-\"  #> No304 \"a\"  \"t\"  \"a\"  \"y\"  \"x\"  #> No306 \"a\"  \"t\"  \"a\"  \"g\"  \"a\"  dat <- phyDat(ex.dna, \"USER\", levels=unique(as.vector(ex.dna))) dist.p(dat) #>       No305 No304 #> No304     4       #> No306     3     4  unlink(\"exdna.txt\")"},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance Hadamard — distanceHadamard","title":"Distance Hadamard — distanceHadamard","text":"Distance Hadamard produces spectra splits distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance Hadamard — distanceHadamard","text":"","code":"distanceHadamard(dm, eps = 0.001)"},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance Hadamard — distanceHadamard","text":"dm distance matrix. eps Threshold value splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance Hadamard — distanceHadamard","text":"distanceHadamard returns matrix. first column contains distance spectra, second one edge-spectra. eps positive object splits greater eps returned.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distance Hadamard — distanceHadamard","text":"Hendy, M. D. Penny, D. (1993). Spectral Analysis Phylogenetic Data. Journal Classification, 10, 5-24.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance Hadamard — distanceHadamard","text":"Klaus Schliep klaus.schliep@gmail.com, Tim White","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance Hadamard — distanceHadamard","text":"","code":"data(yeast) dm <- dist.hamming(yeast) dm <- as.matrix(dm) fit <- distanceHadamard(dm) lento(fit)  plot(as.networx(fit))"},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate nucleic acid sequences into codons — dna2codon","title":"Translate nucleic acid sequences into codons — dna2codon","text":"function transforms dna2codon DNA sequences codon sequences, codon2dna transform way.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate nucleic acid sequences into codons — dna2codon","text":"","code":"dna2codon(x, codonstart = 1, code = 1, ambiguity = \"---\", ...)  codon2dna(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate nucleic acid sequences into codons — dna2codon","text":"x object containing sequences. codonstart integer giving start translation. 1, 2, 3, larger values accepted effect start translation within sequence. code ncbi genetic code number translation (see details). default standard genetic code used. ambiguity character ambiguous character contrast provided. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate nucleic acid sequences into codons — dna2codon","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate nucleic acid sequences into codons — dna2codon","text":"following genetic codes described . number preceding corresponds code argument. Alignment gaps ambiguities currently ignored sites containing deleted.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Translate nucleic acid sequences into codons — dna2codon","text":"https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Translate nucleic acid sequences into codons — dna2codon","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate nucleic acid sequences into codons — dna2codon","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  dna2codon(Laurasiatherian) #> 47 sequences with 1059 character and 919 different site patterns. #> The states are aaa aac aag aat aca acc acg act aga agc agg agt ata atc atg att caa cac cag cat cca ccc ccg cct cga cgc cgg cgt cta ctc ctg ctt gaa gac gag gat gca gcc gcg gct gga ggc ggg ggt gta gtc gtg gtt tac tat tca tcc tcg tct tgc tgg tgt tta ttc ttg ttt"},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":null,"dir":"Reference","previous_headings":"","what":"Clans, slices and clips — getClans","title":"Clans, slices and clips — getClans","text":"Functions clanistics compute clans, slices, clips unrooted trees functions quantify fragmentation trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clans, slices and clips — getClans","text":"","code":"getClans(tree)  getSlices(tree)  getClips(tree, all = TRUE)  getDiversity(tree, x, norm = TRUE, var.names = NULL, labels = \"new\")  # S3 method for clanistics summary(object, ...)  diversity(tree, X)"},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clans, slices and clips — getClans","text":"tree object class phylo multiPhylo (getDiversity). logical, return just largest clip. x object class phyDat. norm logical, return Equitability Index (default) Shannon Diversity. var.names vector variable names. labels see details. object object summary desired. ... arguments passed methods. X data.frame","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clans, slices and clips — getClans","text":"getClans, getSlices getClips return matrix partitions, matrix ones zeros rows correspond clan, slice clip columns tips. one indicates tip belongs certain partition.  getDiversity returns list tree object, first data.frame equitability index Shannon divergence parsimony scores (p-score) trees variables. data.frame two attributes, first splits object identify taxa tree second splits object containing partitions perfectly fit.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clans, slices and clips — getClans","text":"Every split unrooted tree defines two complementary clans. Thus unrooted binary tree \\(n\\) leaves \\(2n - 3\\) edges, therefore \\(4n - 6\\) clans (including \\(n\\) trivial clans containing one leave). Slices defined pair splits tripartitions, clans. number distinguishable slices binary tree \\(n\\) tips \\(2n^2 - 10n + 12\\). cophenetic distance topology. Namely clips groups leaves maximum pairwise distance smaller threshold.  distance within clip lower distance member clip tip. clip different type partition, defining groups leaves related terms evolutionary distances topology.  Namely, clips groups leaves pairwise path-length distances smaller given threshold value (Lapointe et al. 2010). exists different numbers clips different thresholds, largest (trivial) one whole tree.  always clip containing two leaves smallest pairwise distance. Clans, slices clips can used characterize well vector categorial characters (natives/intruders) fit tree. follow definitions Lapointe et al.(2010).  complete clan clan contains leaves given state/color, can also contain leaves another state/color. clan homogeneous contains leaves one state/color. getDiversity computes either  Shannon Diversity: \\(H = -\\sum_{=1}^{k}(N_i/N) log(N_i/N), N=\\sum_{=1}^{k} N_i\\)   Equitability Index: \\(E = H / log(N)\\)  \\(N_i\\) sizes \\(k\\) largest homogeneous clans intruders.  categories data can separated edge tree E-value zero, maximum equitability (E=1) reached intruders separate clans. getDiversity computes Intruder indices whole tree, complete clans complete slices. Additionally parsimony scores (p-scores) reported. p-score indicates leaves contain one color (p-score=0), leaves can separated single split (perfect clan, p-score=1) pair splits (perfect slice, p-score=2). far 2 states supported (native, intruder), however also possible recode several states native intruder state using contrasts, details see section 2 vignette(\"phangorn-specials\"). Furthermore unknown character states coded ambiguous character, can act either native intruder minimizing number clans changes (parsimony analysis) needed describe tree given data. Set attribute labels \"old\" analysis Schliep et al. (2010) \"new\" names intuitive. diversity returns data.frame parsimony score tree levels variables X. X data.frame column factor rownames X correspond tips trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Clans, slices and clips — getClans","text":"Lapointe, F.-J., Lopez, P., Boucher, Y., Koenig, J., Bapteste, E. (2010) Clanistics: multi-level perspective harvesting unrooted gene trees. Trends Microbiology 18: 341-347 Wilkinson, M., McInerney, J.O., Hirt, R.P., Foster, P.G., Embley, T.M. (2007) clades clans: terms phylogenetic relationships unrooted trees. Trends Ecology Evolution 22: 114-115 Schliep, K., Lopez, P., Lapointe F.-J., Bapteste E. (2011) Harvesting Evolutionary Signals Forest Prokaryotic Gene Trees, Molecular Biology Evolution 28(4): 1393-1405","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clans, slices and clips — getClans","text":"Klaus Schliep klaus.schliep@snv.jussieu.fr Francois-Joseph Lapointe francois-joseph.lapointe@umontreal.ca","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clans, slices and clips — getClans","text":"","code":"set.seed(111) tree <- rtree(10) getClans(tree) #>       t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #>  [1,]  1  0  0  0  0  0  0   0  0  0 #>  [2,]  0  1  0  0  0  0  0   0  0  0 #>  [3,]  0  0  1  0  0  0  0   0  0  0 #>  [4,]  0  0  0  1  0  0  0   0  0  0 #>  [5,]  0  0  0  0  1  0  0   0  0  0 #>  [6,]  0  0  0  0  0  1  0   0  0  0 #>  [7,]  0  0  0  0  0  0  1   0  0  0 #>  [8,]  0  0  0  0  0  0  0   1  0  0 #>  [9,]  0  0  0  0  0  0  0   0  1  0 #> [10,]  0  0  0  0  0  0  0   0  0  1 #> [11,]  0  1  1  1  1  1  1   1  1  1 #> [12,]  1  0  1  1  1  1  1   1  1  1 #> [13,]  1  1  0  1  1  1  1   1  1  1 #> [14,]  1  1  1  0  1  1  1   1  1  1 #> [15,]  1  1  1  1  0  1  1   1  1  1 #> [16,]  1  1  1  1  1  0  1   1  1  1 #> [17,]  1  1  1  1  1  1  0   1  1  1 #> [18,]  1  1  1  1  1  1  1   0  1  1 #> [19,]  1  1  1  1  1  1  1   1  0  1 #> [20,]  1  1  1  1  1  1  1   1  1  0 #> [21,]  1  1  1  0  0  0  0   0  0  0 #> [22,]  0  1  1  0  0  0  0   0  0  0 #> [23,]  0  0  0  0  1  1  1   1  1  1 #> [24,]  0  0  0  0  0  1  1   1  1  1 #> [25,]  0  0  0  0  0  1  1   1  0  0 #> [26,]  0  0  0  0  0  0  1   1  0  0 #> [27,]  0  0  0  0  0  0  0   0  1  1 #> [28,]  0  0  0  1  1  1  1   1  1  1 #> [29,]  1  0  0  1  1  1  1   1  1  1 #> [30,]  1  1  1  1  0  0  0   0  0  0 #> [31,]  1  1  1  1  1  0  0   0  0  0 #> [32,]  1  1  1  1  1  0  0   0  1  1 #> [33,]  1  1  1  1  1  1  0   0  1  1 #> [34,]  1  1  1  1  1  1  1   1  0  0 getClips(tree, all=TRUE) #>      t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #> [1,]  1  0  1  0  0  0  0   0  0  0 #> [2,]  0  0  0  0  0  0  1   1  0  0 #> [3,]  0  0  0  0  0  0  0   0  1  1 getSlices(tree) #>        t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #>   [1,]  0  0  1  1  1  1  1   1  1  1 #>   [2,]  0  1  0  1  1  1  1   1  1  1 #>   [3,]  0  1  1  0  1  1  1   1  1  1 #>   [4,]  0  1  1  1  0  1  1   1  1  1 #>   [5,]  0  1  1  1  1  0  1   1  1  1 #>   [6,]  0  1  1  1  1  1  0   1  1  1 #>   [7,]  0  1  1  1  1  1  1   0  1  1 #>   [8,]  0  1  1  1  1  1  1   1  0  1 #>   [9,]  0  1  1  1  1  1  1   1  1  0 #>  [10,]  0  1  1  1  0  0  0   0  0  0 #>  [11,]  0  1  1  1  1  0  0   0  0  0 #>  [12,]  0  1  1  1  1  0  0   0  1  1 #>  [13,]  0  1  1  1  1  1  0   0  1  1 #>  [14,]  0  1  1  1  1  1  1   1  0  0 #>  [15,]  1  0  1  0  1  1  1   1  1  1 #>  [16,]  1  0  1  1  0  1  1   1  1  1 #>  [17,]  1  0  1  1  1  0  1   1  1  1 #>  [18,]  1  0  1  1  1  1  0   1  1  1 #>  [19,]  1  0  1  1  1  1  1   0  1  1 #>  [20,]  1  0  1  1  1  1  1   1  0  1 #>  [21,]  1  0  1  1  1  1  1   1  1  0 #>  [22,]  1  0  1  0  0  0  0   0  0  0 #>  [23,]  1  0  1  1  0  0  0   0  0  0 #>  [24,]  1  0  1  1  1  0  0   0  0  0 #>  [25,]  1  0  1  1  1  0  0   0  1  1 #>  [26,]  1  0  1  1  1  1  0   0  1  1 #>  [27,]  1  0  1  1  1  1  1   1  0  0 #>  [28,]  1  1  0  0  1  1  1   1  1  1 #>  [29,]  1  1  0  1  0  1  1   1  1  1 #>  [30,]  1  1  0  1  1  0  1   1  1  1 #>  [31,]  1  1  0  1  1  1  0   1  1  1 #>  [32,]  1  1  0  1  1  1  1   0  1  1 #>  [33,]  1  1  0  1  1  1  1   1  0  1 #>  [34,]  1  1  0  1  1  1  1   1  1  0 #>  [35,]  1  1  0  0  0  0  0   0  0  0 #>  [36,]  1  1  0  1  0  0  0   0  0  0 #>  [37,]  1  1  0  1  1  0  0   0  0  0 #>  [38,]  1  1  0  1  1  0  0   0  1  1 #>  [39,]  1  1  0  1  1  1  0   0  1  1 #>  [40,]  1  1  0  1  1  1  1   1  0  0 #>  [41,]  1  1  1  0  0  1  1   1  1  1 #>  [42,]  1  1  1  0  1  0  1   1  1  1 #>  [43,]  1  1  1  0  1  1  0   1  1  1 #>  [44,]  1  1  1  0  1  1  1   0  1  1 #>  [45,]  1  1  1  0  1  1  1   1  0  1 #>  [46,]  1  1  1  0  1  1  1   1  1  0 #>  [47,]  1  0  0  0  1  1  1   1  1  1 #>  [48,]  1  1  1  0  1  0  0   0  0  0 #>  [49,]  1  1  1  0  1  0  0   0  1  1 #>  [50,]  1  1  1  0  1  1  0   0  1  1 #>  [51,]  1  1  1  0  1  1  1   1  0  0 #>  [52,]  1  1  1  1  0  0  1   1  1  1 #>  [53,]  1  1  1  1  0  1  0   1  1  1 #>  [54,]  1  1  1  1  0  1  1   0  1  1 #>  [55,]  1  1  1  1  0  1  1   1  0  1 #>  [56,]  1  1  1  1  0  1  1   1  1  0 #>  [57,]  0  0  0  1  0  1  1   1  1  1 #>  [58,]  1  0  0  1  0  1  1   1  1  1 #>  [59,]  1  1  1  1  0  0  0   0  1  1 #>  [60,]  1  1  1  1  0  1  0   0  1  1 #>  [61,]  1  1  1  1  0  1  1   1  0  0 #>  [62,]  1  1  1  1  1  0  0   1  1  1 #>  [63,]  1  1  1  1  1  0  1   0  1  1 #>  [64,]  1  1  1  1  1  0  1   1  0  1 #>  [65,]  1  1  1  1  1  0  1   1  1  0 #>  [66,]  0  0  0  0  1  0  1   1  1  1 #>  [67,]  0  0  0  0  0  0  1   1  1  1 #>  [68,]  0  0  0  1  1  0  1   1  1  1 #>  [69,]  1  0  0  1  1  0  1   1  1  1 #>  [70,]  1  1  1  1  1  0  1   1  0  0 #>  [71,]  1  1  1  1  1  1  0   1  0  1 #>  [72,]  1  1  1  1  1  1  0   1  1  0 #>  [73,]  0  0  0  0  1  1  0   1  1  1 #>  [74,]  0  0  0  0  0  1  0   1  1  1 #>  [75,]  0  0  0  0  0  1  0   1  0  0 #>  [76,]  0  0  0  1  1  1  0   1  1  1 #>  [77,]  1  0  0  1  1  1  0   1  1  1 #>  [78,]  1  1  1  1  1  1  0   1  0  0 #>  [79,]  1  1  1  1  1  1  1   0  0  1 #>  [80,]  1  1  1  1  1  1  1   0  1  0 #>  [81,]  0  0  0  0  1  1  1   0  1  1 #>  [82,]  0  0  0  0  0  1  1   0  1  1 #>  [83,]  0  0  0  0  0  1  1   0  0  0 #>  [84,]  0  0  0  1  1  1  1   0  1  1 #>  [85,]  1  0  0  1  1  1  1   0  1  1 #>  [86,]  1  1  1  1  1  1  1   0  0  0 #>  [87,]  0  0  0  0  1  1  1   1  0  1 #>  [88,]  0  0  0  0  0  1  1   1  0  1 #>  [89,]  0  0  0  1  1  1  1   1  0  1 #>  [90,]  1  0  0  1  1  1  1   1  0  1 #>  [91,]  1  1  1  1  1  0  0   0  0  1 #>  [92,]  1  1  1  1  1  1  0   0  0  1 #>  [93,]  0  0  0  0  1  1  1   1  1  0 #>  [94,]  0  0  0  0  0  1  1   1  1  0 #>  [95,]  0  0  0  1  1  1  1   1  1  0 #>  [96,]  1  0  0  1  1  1  1   1  1  0 #>  [97,]  1  1  1  1  1  0  0   0  1  0 #>  [98,]  1  1  1  1  1  1  0   0  1  0 #>  [99,]  0  0  0  0  1  0  0   0  1  1 #> [100,]  0  0  0  0  1  1  0   0  1  1 #> [101,]  0  0  0  0  1  1  1   1  0  0 #> [102,]  0  0  0  0  0  1  0   0  1  1 #> [103,]  0  0  0  1  1  0  0   0  0  0 #> [104,]  0  0  0  1  1  0  0   0  1  1 #> [105,]  0  0  0  1  1  1  0   0  1  1 #> [106,]  0  0  0  1  1  1  1   1  0  0 #> [107,]  1  0  0  1  0  0  0   0  0  0 #> [108,]  1  0  0  1  1  0  0   0  0  0 #> [109,]  1  0  0  1  1  0  0   0  1  1 #> [110,]  1  0  0  1  1  1  0   0  1  1 #> [111,]  1  0  0  1  1  1  1   1  0  0 #> [112,]  1  1  1  1  1  1  0   0  0  0  set.seed(123) trees <- rmtree(10, 20) X <- matrix(sample(c(\"red\", \"blue\", \"violet\"), 100, TRUE, c(.5,.4, .1)),    ncol=5, dimnames=list(paste('t',1:20, sep=\"\"), paste('Var',1:5, sep=\"_\"))) x <- phyDat(X, type = \"USER\", levels = c(\"red\", \"blue\"), ambiguity=\"violet\") plot(trees[[1]], \"u\", tip.color = X[trees[[1]]$tip,1])  # intruders are blue   (divTab <- getDiversity(trees, x, var.names=colnames(X))) #> Warning: The variable names have changed #>    tree variable    E clan # natives # intruder # unknown   E slice # intruder #> 1     1    Var_1 0.8568636         9         10         1 1.0000000          7 #> 2     1    Var_2 0.6562658        11          7         2 0.7500000          4 #> 3     1    Var_3 0.7500962         8         11         1 0.8018797          8 #> 4     1    Var_4 0.9474428         7         11         2 1.0000000          9 #> 5     1    Var_5 1.0000000         8         10         2 1.0000000          9 #> 6     2    Var_1 0.8568636         9         10         1 1.0000000          7 #> 7     2    Var_2 0.7964530        11          7         2 0.8277294          5 #> 8     2    Var_3 0.9474428         8         11         1 1.0000000          9 #> 9     2    Var_4 0.8224909         7         11         2 0.9166667          8 #> 10    2    Var_5 0.6387640         8         10         2 0.7420981          6 #> 11    3    Var_1 0.8795880         9         10         1 0.9166667          8 #> 12    3    Var_2 0.8982265        11          7         2 1.0000000          5 #> 13    3    Var_3 0.7372138         8         11         1 0.8982265          7 #> 14    3    Var_4 0.8948855         7         11         2 0.9298967          9 #> 15    3    Var_5 1.0000000         8         10         2 1.0000000          9 #> 16    4    Var_1 0.8795880         9         10         1 0.9166667          8 #> 17    4    Var_2 0.8982265        11          7         2 1.0000000          5 #> 18    4    Var_3 0.7372138         8         11         1 0.8982265          7 #> 19    4    Var_4 0.8948855         7         11         2 0.9298967          9 #> 20    4    Var_5 1.0000000         8         10         2 1.0000000          9 #> 21    5    Var_1 0.7966576         9         10         1 0.8982265          7 #> 22    5    Var_2 0.8982265        11          7         2 1.0000000          5 #> 23    5    Var_3 0.8224909         8         11         1 0.9166667          8 #> 24    5    Var_4 0.5699628         7         11         2 0.6934264          6 #> 25    5    Var_5 0.4729033         8         10         2 0.7500000          4 #> 26    6    Var_1 0.7966576         9         10         1 0.8982265          7 #> 27    6    Var_2 0.8982265        11          7         2 1.0000000          5 #> 28    6    Var_3 0.8224909         8         11         1 0.9166667          8 #> 29    6    Var_4 1.0000000         7         11         2 1.0000000         10 #> 30    6    Var_5 0.9397940         8         10         2 1.0000000          8 #> 31    7    Var_1 0.8795880         9         10         1 0.9166667          8 #> 32    7    Var_2 1.0000000        11          7         2 1.0000000          6 #> 33    7    Var_3 0.9474428         8         11         1 1.0000000          9 #> 34    7    Var_4 0.7500962         7         11         2 0.8018797          8 #> 35    7    Var_5 0.9397940         8         10         2 1.0000000          8 #> 36    8    Var_1 0.8795880         9         10         1 0.9166667          8 #> 37    8    Var_2 0.8982265        11          7         2 1.0000000          5 #> 38    8    Var_3 0.8224909         8         11         1 0.9166667          8 #> 39    8    Var_4 0.6846566         7         11         2 0.7964530          7 #> 40    8    Var_5 0.8568636         8         10         2 1.0000000          7 #> 41    9    Var_1 0.7364516         9         10         1 0.7964530          7 #> 42    9    Var_2 0.7964530        11          7         2 0.8277294          5 #> 43    9    Var_3 0.8948855         8         11         1 0.9298967          9 #> 44    9    Var_4 0.7897710         7         11         2 0.7896901          9 #> 45    9    Var_5 0.7591760         8         10         2 1.0000000          6 #> 46   10    Var_1 0.5903090         9         10         1 0.8277294          5 #> 47   10    Var_2 0.8982265        11          7         2 1.0000000          5 #> 48   10    Var_3 0.8224909         8         11         1 0.9166667          8 #> 49   10    Var_4 0.8750481         7         11         2 1.0000000          8 #> 50   10    Var_5 0.9397940         8         10         2 1.0000000          8 #>    # unknown E melange # intruder # unknown bs 1 bs 2 p-score #> 1          1 1.0000000          6         1   NA   NA       8 #> 2          2 1.0000000          2         2   NA   NA       4 #> 3          1 1.0000000          5         1   NA   NA       6 #> 4          2 1.0000000          8         2   NA   NA       7 #> 5          2 1.0000000          8         2   NA   NA       7 #> 6          1 1.0000000          6         1   NA   NA       7 #> 7          2 1.0000000          3         1   NA   NA       5 #> 8          1 1.0000000          8         1   NA   NA       7 #> 9          2 1.0000000          6         2   NA   NA       5 #> 10         1 0.7500000          4         1   NA   NA       5 #> 11         1 1.0000000          6         1   NA   NA       7 #> 12         2 1.0000000          4         2   NA   NA       6 #> 13         1 1.0000000          5         1   NA   NA       7 #> 14         2 1.0000000          7         1   NA   NA       5 #> 15         2 1.0000000          8         2   NA   NA       8 #> 16         1 1.0000000          6         1   NA   NA       4 #> 17         2 1.0000000          4         2   NA   NA       5 #> 18         1 1.0000000          5         1   NA   NA       6 #> 19         2 1.0000000          7         2   NA   NA       6 #> 20         2 1.0000000          8         2   NA   NA       8 #> 21         1 1.0000000          5         1   NA   NA       7 #> 22         2 1.0000000          4         2   NA   NA       6 #> 23         1 1.0000000          6         1   NA   NA       7 #> 24         0 1.0000000          3         0   NA   NA       5 #> 25         2 1.0000000          2         2   NA   NA       4 #> 26         1 1.0000000          5         1   NA   NA       6 #> 27         1 1.0000000          4         1   NA   NA       6 #> 28         1 1.0000000          6         1   NA   NA       6 #> 29         2 1.0000000          9         2   NA   NA       7 #> 30         2 1.0000000          7         2   NA   NA       7 #> 31         1 1.0000000          6         0   NA   NA       6 #> 32         2 1.0000000          5         2   NA   NA       6 #> 33         1 1.0000000          8         1   NA   NA       7 #> 34         1 1.0000000          5         1   NA   NA       5 #> 35         2 1.0000000          7         2   NA   NA       7 #> 36         1 1.0000000          6         0   NA   NA       8 #> 37         2 1.0000000          4         2   NA   NA       6 #> 38         1 1.0000000          6         1   NA   NA       7 #> 39         2 0.8277294          5         2   NA   NA       6 #> 40         2 1.0000000          6         2   NA   NA       4 #> 41         1 0.8277294          5         1   NA   NA       6 #> 42         2 1.0000000          3         1   NA   NA       4 #> 43         1 1.0000000          7         1   NA   NA       7 #> 44         2 0.7964530          7         2   NA   NA       5 #> 45         2 1.0000000          5         2   NA   NA       6 #> 46         1 1.0000000          3         1   NA   NA       5 #> 47         2 1.0000000          4         2   NA   NA       6 #> 48         1 1.0000000          6         1   NA   NA       5 #> 49         2 1.0000000          7         2   NA   NA       6 #> 50         1 1.0000000          7         1   NA   NA       7 summary(divTab) #>   Variable Natives_only Intruder_only Clan Slice Melange #> 1    Var_1            0             0    0     0      10 #> 2    Var_2            0             0    0     0      10 #> 3    Var_3            0             0    0     0      10 #> 4    Var_4            0             0    0     0      10 #> 5    Var_5            0             0    0     0      10"},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":null,"dir":"Reference","previous_headings":"","what":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"collection functions perform Hadamard conjugation.   Hadamard matrix H vector v using fast Hadamard multiplication.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"","code":"hadamard(x)  fhm(v)  h4st(obj, levels = c(\"a\", \"c\", \"g\", \"t\"))  h2st(obj, eps = 0.001)"},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"x vector length \\(2^n\\), n integer. v vector length \\(2^n\\), n integer. obj data.frame character matrix, typical sequence alignment. levels levels sequences. eps Threshold value splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"hadamard returns Hadamard matrix. fhm returns fast Hadamard multiplication.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"h2st h4st perform Hadamard conjugation 2-state (binary, RY-coded) 4-state (DNA/RNA) data. write.nexus.splits writes splits returned h2st distanceHadamard nexus file, can processed Spectronet SplitsTree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"Hendy, M.D. (1989). relationship simple evolutionary tree models observable sequence data. Systematic Zoology, 38 310--321. Hendy, M. D. Penny, D. (1993). Spectral Analysis Phylogenetic Data. Journal Classification, 10, 5--24. Hendy, M. D. (2005). Hadamard conjugation: analytical tool phylogenetics. O. Gascuel, editor, Mathematics evolution phylogeny, Oxford University Press, Oxford Waddell P. J. (1995). Statistical methods phylogenetic analysis: Including hadamard conjugation, LogDet transforms, maximum likelihood. PhD thesis.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"","code":"H <- hadamard(3) v <- 1:8 H %*% v #>      [,1] #> [1,]   36 #> [2,]   -4 #> [3,]   -8 #> [4,]    0 #> [5,]  -16 #> [6,]    0 #> [7,]    0 #> [8,]    0 fhm(v) #> [1]  36  -4  -8   0 -16   0   0   0  data(yeast)  # RY-coding dat_ry <- acgt2ry(yeast) #> Warning: Found unknown characters (not supplied in levels). Deleted sites with unknown states. fit2 <- h2st(dat_ry) lento(fit2)   # write.nexus.splits(fit2, file = \"test.nxs\") # read this file into Spectronet or SplitsTree to show the network  fit4 <- h4st(yeast) old.par <- par(no.readonly = TRUE) par(mfrow=c(3,1)) lento(fit4[[1]], main=\"Transversion\") lento(fit4[[2]], main=\"Transition 1\") lento(fit4[[3]], main=\"Transition 2\")  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify splits in a network — identify.networx","title":"Identify splits in a network — identify.networx","text":"identify.networx reads position graphics pointer mouse button pressed. returns split belonging edge closest pointer. network must plotted beforehand.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify splits in a network — identify.networx","text":"","code":"# S3 method for networx identify(x, quiet = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify splits in a network — identify.networx","text":"x object class networx quiet logical controlling whether print message inviting user click tree. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify splits in a network — identify.networx","text":"identify.networx returns splits object.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify splits in a network — identify.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify splits in a network — identify.networx","text":"","code":"if (FALSE) { data(yeast) dm <- dist.ml(yeast) nnet <- neighborNet(dm) plot(nnet) identify(nnet) # click close to an edge }"},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of a Sequence Alignment — image.phyDat","title":"Plot of a Sequence Alignment — image.phyDat","text":"function plots image alignment sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of a Sequence Alignment — image.phyDat","text":"","code":"# S3 method for phyDat image(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of a Sequence Alignment — image.phyDat","text":"x object containing sequences, object class phyDat. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot of a Sequence Alignment — image.phyDat","text":"wrapper using image.DNAbin image.AAbin.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":null,"dir":"Reference","previous_headings":"","what":"Lento plot — lento","title":"Lento plot — lento","text":"lento plot represents support conflict splits/bipartitions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lento plot — lento","text":"","code":"lento(obj, xlim = NULL, ylim = NULL, main = \"Lento plot\", sub = NULL,   xlab = NULL, ylab = NULL, bipart = TRUE, trivial = FALSE,   col = rgb(0, 0, 0, 0.5), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lento plot — lento","text":"obj object class phylo, multiPhylo splits xlim graphical parameter ylim graphical parameter main graphical parameter sub graphical parameter xlab graphical parameter ylab graphical parameter bipart plot bipartition information. trivial logical, whether present trivial splits (default FALSE). col color splits / bipartition. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lento plot — lento","text":"lento returns plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lento plot — lento","text":"Lento, G.M., Hickson, R.E., Chambers G.K., Penny, D. (1995) Use spectral analysis test hypotheses origin pinninpeds. Molecular Biology Evolution, 12, 28-52.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lento plot — lento","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lento plot — lento","text":"","code":"data(yeast) yeast.ry <- acgt2ry(yeast) #> Warning: Found unknown characters (not supplied in levels). Deleted sites with unknown states. splits.h <- h2st(yeast.ry) lento(splits.h, trivial=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum agreement subtree — mast","title":"Maximum agreement subtree — mast","text":"mast computes maximum agreement subtree (MAST).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum agreement subtree — mast","text":"","code":"mast(x, y, tree = TRUE, rooted = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum agreement subtree — mast","text":"x tree, .e. object class phylo. y tree, .e. object class phylo. tree logical, TRUE returns tree wise tip labels maximum agreement subtree. rooted logical TRUE treats trees rooted otherwise unrooted.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum agreement subtree — mast","text":"mast returns vector tip labels MAST.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum agreement subtree — mast","text":"code derived code example Valiente (2009). version unrooted trees much slower.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Maximum agreement subtree — mast","text":"G. Valiente (2009). Combinatorial Pattern Matching Algorithms Computational Biology using Perl R. Taylor & Francis/CRC Press","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum agreement subtree — mast","text":"Klaus Schliep klaus.schliep@gmail.com based code Gabriel Valiente","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum agreement subtree — mast","text":"","code":"tree1 <- rtree(100) tree2 <- rSPR(tree1, 5) tips <- mast(tree1, tree2)"},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum clade credibility tree — maxCladeCred","title":"Maximum clade credibility tree — maxCladeCred","text":"maxCladeCred computes maximum clade credibility tree sample trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum clade credibility tree — maxCladeCred","text":"","code":"maxCladeCred(x, tree = TRUE, part = NULL, rooted = TRUE)  mcc(x, tree = TRUE, part = NULL, rooted = TRUE)  allCompat(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum clade credibility tree — maxCladeCred","text":"x x object class multiPhylo phylo tree logical indicating whether return tree clade credibility (default) clade credibility score trees. part list partitions returned prop.part rooted logical, FALSE tree highest maximum bipartition credibility returned.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum clade credibility tree — maxCladeCred","text":"tree (object class phylo) highest clade credibility numeric vector clade credibilities tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum clade credibility tree — maxCladeCred","text":"far just best tree returned. annotations transformations edge length performed. list partition provided clade credibility computed trees x. allCompat returns 50% majority rule consensus tree added compatible splits similar option allcompat MrBayes.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum clade credibility tree — maxCladeCred","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum clade credibility tree — maxCladeCred","text":"","code":"data(Laurasiatherian) set.seed(42) bs <- bootstrap.phyDat(Laurasiatherian,   FUN = function(x)upgma(dist.hamming(x)), bs=100)  strict_consensus <- consensus(bs) majority_consensus <- consensus(bs, p=.5) all_compat <- allCompat(bs) max_clade_cred <- maxCladeCred(bs)  old.par <- par(no.readonly = TRUE) par(mfrow = c(2,2), mar = c(1,4,1,1)) plot(strict_consensus, main=\"Strict consensus tree\") plot(majority_consensus, main=\"Majority consensus tree\") plot(all_compat, main=\"Majority consensus tree with compatible splits\") plot(max_clade_cred, main=\"Maximum clade credibility tree\")  par(old.par)  # compute clade credibility for trees given a prop.part object pp <- prop.part(bs) tree <- rNNI(bs[[1]], 20) maxCladeCred(c(tree, bs[[1]]), tree=FALSE, part = pp) #> [1]      -Inf -36.10917 # first value likely be -Inf"},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree manipulation — getRoot","title":"Tree manipulation — getRoot","text":"midpoint performs midpoint rooting tree.  pruneTree produces consensus tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree manipulation — getRoot","text":"","code":"getRoot(tree)  midpoint(tree, node.labels = \"support\", ...)  # S3 method for phylo midpoint(tree, node.labels = \"support\", ...)  # S3 method for multiPhylo midpoint(tree, node.labels = \"support\", ...)  pruneTree(tree, ..., FUN = \">=\")"},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree manipulation — getRoot","text":"tree object class phylo. node.labels node labels 'support' values (edges), 'label' labels get 'deleted'? ... arguments, passed methods. FUN function evaluated nodelabels, result must logical.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree manipulation — getRoot","text":"pruneTree midpoint tree. getRoot returns root node.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tree manipulation — getRoot","text":"pruneTree prunes back tree produces consensus tree, trees already containing nodelabels.  assumes nodelabels numerical character allows conversion numerical, uses .numeric(.character(tree$node.labels)) convert .  midpoint far transform node.labels properly.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tree manipulation — getRoot","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree manipulation — getRoot","text":"","code":"tree <- rtree(10, rooted = FALSE) tree$node.label <- c(\"\", round(runif(tree$Nnode-1), digits=3))  tree2 <- midpoint(tree) tree3 <- pruneTree(tree, .5)  old.par <- par(no.readonly = TRUE) par(mfrow = c(3,1)) plot(tree, show.node.label=TRUE) plot(tree2, show.node.label=TRUE) plot(tree3, show.node.label=TRUE)  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelTest — modelTest","title":"ModelTest — modelTest","text":"Comparison different nucleotide amino acid substitution models","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelTest — modelTest","text":"","code":"modelTest(object, tree = NULL, model = NULL, G = TRUE, I = TRUE,   FREQ = FALSE, k = 4, control = pml.control(epsilon = 1e-08, maxit = 10,   trace = 1), multicore = FALSE, mc.cores = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelTest — modelTest","text":"object object class phyDat pml tree phylogenetic tree. model vector containing substitution models compare \"\" test available models G logical, TRUE (default) (discrete) Gamma model tested logical, TRUE (default) invariant sites tested FREQ logical, FALSE (default) TRUE amino acid frequencies estimated. k number rate classes control list parameters controlling fitting process. multicore logical, whether models estimated parallel. mc.cores number cores use, .e. many child processes run simultaneously. Must least one, parallelization requires least two cores.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModelTest — modelTest","text":"data.frame containing log-likelihood, number estimated parameters, AIC, AICc BIC tested models.  data.frame attributes \"env\" environment contains trees, data calls allow get estimated models, e.g. starting point analysis (see example).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModelTest — modelTest","text":"modelTest estimates specified models given tree data.  mclapply available, computations done parallel. modelTest runs model one thread.  may work within GUI interface work Windows.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ModelTest — modelTest","text":"Burnham, K. P. Anderson, D. R (2002) Model selection multimodel inference: practical information-theoretic approach. 2nd ed. Springer, New York Posada, D. Crandall, K.. (1998) MODELTEST: testing model DNA substitution. Bioinformatics 14(9): 817-818 Posada, D. (2008) jModelTest: Phylogenetic Model Averaging. Molecular Biology Evolution 25: 1253-1256 Darriba D., Taboada G.L., Doallo R Posada D. (2011) ProtTest 3: fast selection best-fit models protein evolution. . Bioinformatics 27: 1164-1165","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ModelTest — modelTest","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModelTest — modelTest","text":"","code":"if (FALSE) { example(NJ) (mT <- modelTest(Laurasiatherian, tree, model = c(\"JC\", \"F81\", \"K80\", \"HKY\",                  \"SYM\", \"GTR\")))  # extract best model (best_model <- as.pml(mT))   data(chloroplast) (mTAA <- modelTest(chloroplast, model=c(\"JTT\", \"WAG\", \"LG\")))  # test all available amino acid models (mTAA_all <- modelTest(chloroplast, model=\"all\", multicore=TRUE, mc.cores=2)) }"},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes a neighborNet from a distance matrix — neighborNet","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Computes neighborNet, .e. object class networx distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"","code":"neighborNet(x, ord = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"x distance matrix. ord circular ordering.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"neighborNet returns object class networx.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"neighborNet still experimental. cyclic ordering sometimes differ SplitsTree implementation, ord argument can used enforce certain circular ordering.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Bryant, D. & Moulton, V. (2004) Neighbor-Net: Agglomerative Method Construction Phylogenetic Networks. Molecular Biology Evolution, 2004, 21, 255-265","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"","code":"data(yeast) dm <- dist.ml(yeast) nnet <- neighborNet(dm) plot(nnet)"},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree rearrangements. — nni","title":"Tree rearrangements. — nni","text":"nni returns list trees one nearest neighbor interchange away. rNNI rSPR two methods simulate random trees specified number rearrangement apart input tree. methods assume input tree bifurcating. methods may useful simulation studies.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree rearrangements. — nni","text":"","code":"nni(tree)  rNNI(tree, moves = 1, n = length(moves))  rSPR(tree, moves = 1, n = length(moves), k = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree rearrangements. — nni","text":"tree phylogenetic tree, object class phylo. moves Number tree rearrangements transformed tree.  Can vector n Number trees simulated. k defined just SPR distance k performed.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree rearrangements. — nni","text":"object class multiPhylo.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tree rearrangements. — nni","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree rearrangements. — nni","text":"","code":"tree <- rtree(20, rooted = FALSE) trees1 <- nni(tree) trees2 <- rSPR(tree, 2, 10)"},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsimony tree. — acctran","title":"Parsimony tree. — acctran","text":"parsimony returns parsimony score tree using either sankoff fitch algorithm. optim.parsimony tries find maximum parsimony tree using either Nearest Neighbor Interchange (NNI) rearrangements sub tree pruning regrafting (SPR). pratchet implements parsimony ratchet (Nixon, 1999) preferred way search best tree.  random.addition can used produce starting trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsimony tree. — acctran","text":"","code":"acctran(tree, data)  fitch(tree, data, site = \"pscore\")  random.addition(data, tree = NULL, method = \"fitch\")  parsimony(tree, data, method = \"fitch\", cost = NULL, site = \"pscore\")  optim.parsimony(tree, data, method = \"fitch\", cost = NULL, trace = 1,   rearrangements = \"SPR\", ...)  pratchet(data, start = NULL, method = \"fitch\", maxit = 1000,   minit = 100, k = 10, trace = 1, all = TRUE, rearrangements = \"SPR\",   perturbation = \"ratchet\", ...)  sankoff(tree, data, cost = NULL, site = \"pscore\")"},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsimony tree. — acctran","text":"tree tree start nni search . data object class phyDat containing sequences. site return either 'pscore' 'site' wise parsimony scores. method one 'fitch' 'sankoff'. cost cost matrix transitions two states. trace defines much information printed optimization. rearrangements SPR NNI rearrangements. ... arguments passed methods (e.g. model=\"sankoff\" cost matrix). start starting tree can supplied. maxit maximum number iterations ratchet. minit minimum number iterations ratchet. k number rounds ratchet stopped, improvement. return equally good trees just one . perturbation whether use \"ratchet\", \"random_addition\" \"stochastic\" (nni) shuffling tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsimony tree. — acctran","text":"parsimony returns maximum parsimony score (pscore). optim.parsimony returns tree NNI rearrangements. pratchet returns tree list trees containing best tree(s) found search.  acctran returns tree edge length according ACCTRAN criterion.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsimony tree. — acctran","text":"\"SPR\" rearrangements far available \"fitch\" method, \"sankoff\" uses \"NNI\". \"fitch\" algorithm works correct binary trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Parsimony tree. — acctran","text":"Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Nixon, K. (1999) Parsimony Ratchet, New Method Rapid Parsimony Analysis. Cladistics 15, 407-414","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parsimony tree. — acctran","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsimony tree. — acctran","text":"","code":"set.seed(3) data(Laurasiatherian) dm <- dist.hamming(Laurasiatherian) tree <- NJ(dm) parsimony(tree, Laurasiatherian) #> [1] 9796 treeRA <- random.addition(Laurasiatherian) treeSPR <- optim.parsimony(tree, Laurasiatherian) #> Final p-score 9715 after  11 nni operations   # lower number of iterations for the example (to run less than 5 seconds), # keep default values (maxit, minit, k) or increase them for real life # analyses. treeRatchet <- pratchet(Laurasiatherian, start=tree, maxit=100,                         minit=5, k=5, trace=0) # assign edge length (number of substitutions) treeRatchet <- acctran(treeRatchet, Laurasiatherian) # remove edges of length 0 treeRatchet <- di2multi(treeRatchet)  plot(midpoint(treeRatchet)) add.scale.bar(0,0, length=100)   parsimony(c(tree,treeSPR, treeRatchet), Laurasiatherian) #> [1] 9796 9715 9713"},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal phangorn Functions — threshStateC","title":"Internal phangorn Functions — threshStateC","text":"Internal phangorn functions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-internal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal phangorn Functions — threshStateC","text":"","code":"threshStateC(x, thresholds)  candidate_tree(x, method = c(\"unrooted\", \"ultrametric\", \"tipdated\"),   eps = 1e-08, tip.dates = NULL, ...)  hash_phylo(x, ...)  coords(obj, dim = \"3D\")  map_duplicates(x, dist = length(x) < 500, ...)  pmlPen(object, lambda, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","title":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","text":"Allows estimation phylogenetic trees networks using Maximum Likelihood, Maximum Parsimony, distance methods Hadamard conjugation (Schliep 2011). Offers methods tree comparison, model selection visualization phylogenetic networks described Schliep et al. (2017).","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","text":"Maintainer: Klaus Schliep klaus.schliep@gmail.com (ORCID) Authors: Emmanuel Paradis (ORCID) Leonardo de Oliveira Martins (ORCID) Alastair Potts Tim W. White contributors: Cyrill Stachniss [contributor] Michelle Kendall m.kendall@imperial.ac.uk [contributor] Keren Halabi [contributor] Richel Bilderbeek [contributor] Kristin Winchell [contributor] Liam Revell [contributor] Mike Gilchrist [contributor] Jeremy Beaulieu [contributor] Brian O'Meara [contributor] Long Qu [contributor]","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic functions for class phyDat — print.phyDat","title":"Generic functions for class phyDat — print.phyDat","text":"functions help manipulate alignments class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic functions for class phyDat — print.phyDat","text":"","code":"# S3 method for phyDat print(x, ...)  # S3 method for phyDat subset(x, subset, select, site.pattern = TRUE, ...)  # S3 method for phyDat [(x, i, j, ..., drop = FALSE)  # S3 method for phyDat unique(x, incomparables = FALSE, identical = TRUE, ...)  removeUndeterminedSites(x, ...)  removeAmbiguousSites(x)  allSitePattern(n, levels = NULL, names = NULL, type = \"DNA\")"},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic functions for class phyDat — print.phyDat","text":"x object containing sequences. ... arguments passed methods. subset subset taxa. select subset characters. site.pattern select site pattern sites (see details). , j indices rows /columns select drop. may numeric, logical, character (way standard R objects). drop compatibility generic (unused). incomparables compatibility unique. identical TRUE (default) sequences identical, FALSE sequences considered duplicates distance sequences zero (happens frequently ambiguous sites). n Number sequences. levels Level attributes. names Names sequences. type Type sequences (\"DNA\", \"AA\" \"USER\").","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic functions for class phyDat — print.phyDat","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic functions for class phyDat — print.phyDat","text":"allSitePattern generatess possible site patterns can useful simulation studies. details see vignette phangorn-specials. generic function c can used combine sequences unique get unique sequences unique haplotypes. phyDat stores identical columns alignment keeps index original positions. saves memory especially computations usually need done site pattern. example matrix x example 8 columns, column 1 2 also 3 5 identical. phyDat object y 6 site pattern. argument site.pattern=FALSE indexing behaves like original matrix x. site.pattern=TRUE can useful inside functions.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generic functions for class phyDat — print.phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic functions for class phyDat — print.phyDat","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # base frequencies baseFreq(Laurasiatherian) #>         a         c         g         t  #> 0.3321866 0.1990791 0.2040652 0.2646691  # subsetting phyDat objects # the first 5 sequences subset(Laurasiatherian, subset=1:5) #> 5 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # the first 5 characters subset(Laurasiatherian, select=1:5, site.pattern = FALSE) #> 47 sequences with 5 character and 5 different site patterns. #> The states are a c g t  # subsetting with [] Laurasiatherian[1:5, 1:20] #> 5 sequences with 20 character and 17 different site patterns. #> The states are a c g t  # short for subset(Laurasiatherian, subset=1:5, select=1:20, site.pattern = FALSE) #> 5 sequences with 20 character and 17 different site patterns. #> The states are a c g t  # the first 5 site patterns (often more than 5 characters) subset(Laurasiatherian, select=1:5, site.pattern = TRUE) #> 47 sequences with 454 character and 5 different site patterns. #> The states are a c g t   x <- matrix(c(\"a\", \"a\", \"c\", \"g\", \"c\", \"t\", \"a\", \"g\",               \"a\", \"a\", \"c\", \"g\", \"c\", \"t\", \"a\", \"g\",               \"a\", \"a\", \"c\", \"c\", \"c\", \"t\", \"t\", \"g\"), nrow=3, byrow = TRUE,             dimnames = list(c(\"t1\", \"t2\", \"t3\"), 1:8)) (y <- phyDat(x)) #> 3 sequences with 8 character and 6 different site patterns. #> The states are a c g t   subset(y, 1:2) #> 2 sequences with 8 character and 6 different site patterns. #> The states are a c g t  subset(y, 1:2, compress=TRUE) #> 2 sequences with 8 character and 4 different site patterns. #> The states are a c g t   subset(y, select=1:3, site.pattern = FALSE) |> as.character() #>    [,1] [,2] [,3] #> t1 \"a\"  \"a\"  \"c\"  #> t2 \"a\"  \"a\"  \"c\"  #> t3 \"a\"  \"a\"  \"c\"  subset(y, select=1:3, site.pattern = TRUE) |> as.character() #>    [,1] [,2] [,3] [,4] [,5] #> t1 \"a\"  \"a\"  \"c\"  \"c\"  \"g\"  #> t2 \"a\"  \"a\"  \"c\"  \"c\"  \"g\"  #> t3 \"a\"  \"a\"  \"c\"  \"c\"  \"c\"  y[,1:3] # same as subset(y, select=1:3, site.pattern = FALSE) #> 3 sequences with 3 character and 2 different site patterns. #> The states are a c g t   # Compute all possible site patterns # for nucleotides there $4 ^ (number of tips)$ patterns allSitePattern(5) #> 5 sequences with 1024 character and 1024 different site patterns. #> The states are a c g t"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"plot phylogenetic networks — plot.networx","title":"plot phylogenetic networks — plot.networx","text":"far parameters behave rgl \"3D\" basic graphic \"2D\" device.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot phylogenetic networks — plot.networx","text":"","code":"# S3 method for networx plot(x, type = \"equal angle\", use.edge.length = TRUE,   show.tip.label = TRUE, show.edge.label = FALSE, edge.label = NULL,   show.node.label = FALSE, node.label = NULL, show.nodes = FALSE,   tip.color = \"black\", edge.color = \"black\", edge.width = 3,   edge.lty = 1, split.color = NULL, split.width = NULL,   split.lty = NULL, font = 3, cex = par(\"cex\"), cex.node.label = cex,   cex.edge.label = cex, col.node.label = tip.color,   col.edge.label = tip.color, font.node.label = font,   font.edge.label = font, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot phylogenetic networks — plot.networx","text":"x object class \"networx\" type \"3D\" plot using rgl \"equal angle\" \"2D\" normal device. use.edge.length logical indicating whether use edge weights network draw branches (default) . show.tip.label logical indicating whether show tip labels graph (defaults TRUE, .e. labels shown). show.edge.label logical indicating whether show tip labels graph. edge.label additional vector edge labels (normally needed). show.node.label logical indicating whether show node labels (see example). node.label additional vector node labels (normally needed). show.nodes logical indicating whether show nodes (see example). tip.color colors used tip labels. edge.color colors used draw edges. edge.width width used draw edges. edge.lty vector line types. split.color colors used draw edges. split.width width used draw edges. split.lty vector line types. font integer specifying type font labels: 1 (plain text), 2 (bold), 3 (italic, default), 4 (bold italic). cex numeric value giving factor scaling labels. cex.node.label numeric value giving factor scaling node labels. cex.edge.label numeric value giving factor scaling edge labels. col.node.label colors used node labels. col.edge.label colors used edge labels. font.node.label font used node labels. font.edge.label font used edge labels. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"plot phylogenetic networks — plot.networx","text":"Often easier safer supply vectors graphical parameters splits (e.g. splits.color) edges. overwrite values edge.color.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"plot phylogenetic networks — plot.networx","text":"internal representation likely change.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"plot phylogenetic networks — plot.networx","text":"Dress, .W.M. Huson, D.H. (2004) Constructing Splits Graphs IEEE/ACM Transactions Computational Biology Bioinformatics (TCBB), 1(3), 109--115 Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol. 8, 1212--1220. doi:10.1111/2041-210X.12760","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot phylogenetic networks — plot.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot phylogenetic networks — plot.networx","text":"","code":"set.seed(1) tree1 <- rtree(20, rooted=FALSE) sp <- as.splits(rNNI(tree1, n=10)) net <- as.networx(sp) plot(net)  if (FALSE) { # also see example in consensusNet example(consensusNet) }"},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting trees with bootstrap values — plotBS","title":"Plotting trees with bootstrap values — plotBS","text":"plotBS plots phylogenetic tree bootstrap values assigned (internal) edges. can also used assign bootstrap values phylogenetic tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting trees with bootstrap values — plotBS","text":"","code":"plotBS(tree, BStrees, type = \"unrooted\", method = \"FBP\",   bs.col = \"black\", bs.adj = NULL, digits = 3, p = 0, frame = \"none\",   ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting trees with bootstrap values — plotBS","text":"tree tree edges bootstrap values plotted. BStrees list trees (object class \"multiPhylo\"). type type tree plot, one \"phylogram\", \"cladogram\", \"fan\", \"unrooted\", \"radial\" \"none\". type \"none\" tree returned bootstrap values assigned node labels. method either \"FBP\" classical bootstrap (default) \"TBE\" (transfer bootstrap) bs.col color bootstrap support labels. bs.adj one two numeric values specifying horizontal vertical justification bootstrap labels. digits integer indicating number decimal places. p plot support values higher percentage number (default 0). frame character string specifying kind frame printed around bootstrap values. must one \"none\" (default), \"rect\" \"circle\". ... parameters used plot.phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting trees with bootstrap values — plotBS","text":"plotBS returns silently tree, .e. object class phylo bootstrap values node labels. argument BStrees optional supplied labels supplied node.label slot used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plotting trees with bootstrap values — plotBS","text":"plotBS can either assign classical Felsenstein’s bootstrap proportions (FBP) (Felsenstein (1985), Hendy & Penny (1985))  transfer bootstrap expectation (TBE) Lemoine et al. (2018). Using option type==\"n\" just assigns bootstrap values return tree without plotting .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plotting trees with bootstrap values — plotBS","text":"Felsenstein J. (1985) Confidence limits phylogenies. approach using bootstrap. Evolution 39, 783--791 Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D., De Oliveira, T., & Gascuel, O. (2018). Renewing Felsenstein’s phylogenetic bootstrap era big data. Nature, 556(7702), 452--456. Penny D. Hendy M.D. (1985) Testing methods evolutionary tree construction. Cladistics 1, 266--278 Penny D. Hendy M.D. (1986) Estimating reliability evolutionary trees. Molecular Biology Evolution 3, 403--417","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plotting trees with bootstrap values — plotBS","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting trees with bootstrap values — plotBS","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") # RAxML best-known tree with bipartition support (from previous analysis) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bipartitions.woodmouse\")) # RAxML bootstrap trees (from previous analysis) raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.woodmouse\")) par(mfrow=c(1,2)) plotBS(raxml.tree,  raxml.bootstrap, \"p\") plotBS(raxml.tree,  raxml.bootstrap, \"p\", \"TBE\")"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":null,"dir":"Reference","previous_headings":"","what":"Auxiliary for Controlling Fitting — pml.control","title":"Auxiliary for Controlling Fitting — pml.control","text":"Auxiliary functions optim.pml fitting. Use construct control ratchet.par argument.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auxiliary for Controlling Fitting — pml.control","text":"","code":"pml.control(epsilon = 1e-08, maxit = 10, trace = 1, tau = 1e-08)  ratchet.control(iter = 20L, maxit = 200L, minit = 25L, prop = 1/2,   rell = FALSE, bs = 100L)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auxiliary for Controlling Fitting — pml.control","text":"epsilon Stop criterion optimization (see details). maxit Maximum number iterations (see details). trace Show output optimization (see details). tau minimal edge length. iter Number iterations stop change. minit Minimum number iterations. prop used rearrangement=stochstic. many NNI moves added tree proportion number taxa.´","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auxiliary for Controlling Fitting — pml.control","text":"list components named arguments controlling fitting process.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Auxiliary for Controlling Fitting — pml.control","text":"pml.control controls fitting process. epsilon maxit defined outer loop, affects pmlCluster, pmlPart pmlMix.  epsilon defined (logLik(k)-logLik(k+1))/logLik(k+1), seems good heuristics works reasonably small large trees alignments. trace set zero put shown, functions called internally trace decreased one, higher trace produces feedback.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Auxiliary for Controlling Fitting — pml.control","text":"Minh, B. Q., Nguyen, M. . T., & von Haeseler, . (2013). Ultrafast approximation phylogenetic bootstrap. Molecular biology evolution, 30(5), 1188-1195.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Auxiliary for Controlling Fitting — pml.control","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auxiliary for Controlling Fitting — pml.control","text":"","code":"pml.control() #> $epsilon #> [1] 1e-08 #>  #> $maxit #> [1] 10 #>  #> $trace #> [1] 1 #>  #> $tau #> [1] 1e-08 #>  pml.control(maxit=25) #> $epsilon #> [1] 1e-08 #>  #> $maxit #> [1] 25 #>  #> $trace #> [1] 1 #>  #> $tau #> [1] 1e-08 #>"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal maximum likelihood functions. — lli","title":"Internal maximum likelihood functions. — lli","text":"functions internally used likelihood computations pml optim.pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal maximum likelihood functions. — lli","text":"","code":"lli(data, tree = NULL, ...)  edQt(Q = c(1, 1, 1, 1, 1, 1), bf = c(0.25, 0.25, 0.25, 0.25))  pml.free()  pml.init(data, k = 1L)  pml.fit(tree, data, bf = rep(1/length(levels), length(levels)), shape = 1,   k = 1, Q = rep(1, length(levels) * (length(levels) - 1)/2),   levels = attr(data, \"levels\"), inv = 0, rate = 1, g = NULL,   w = NULL, eig = NULL, INV = NULL, ll.0 = NULL, llMix = NULL,   wMix = 0, ..., site = FALSE, Mkv = FALSE, site.rate = \"gamma\")"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal maximum likelihood functions. — lli","text":"data alignment, object class phyDat. tree phylogenetic tree, object class phylo. ... arguments passed methods. Q vector containing lower triangular part rate matrix. bf Base frequencies. k Number intervals discrete gamma distribution. shape Shape parameter gamma distribution. levels alphabet used e.g. c(\"\", \"c\", \"g\", \"t\") DNA inv Proportion invariable sites. rate Rate. g vector quantiles (default NULL) w vector probabilities (default NULL) eig Eigenvalue decomposition Q INV Sparse representation invariant sites ll.0 default NULL llMix default NULL wMix default NULL site return log-likelihood vector sitewise likelihood values Mkv indicate Lewis' Mkv estimated. site.rate Indicates type gamma distribution use. Options \"gamma\" approach Yang 1994 (default), \"quadrature\" Laguerre quadrature approach Felsenstein 2001 \"freerate\" .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal maximum likelihood functions. — lli","text":"pml.fit returns log-likelihood.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal maximum likelihood functions. — lli","text":"functions exported used different packages far package coalescentMCMC, intended end user. functions call C code far less forgiving import expect pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Internal maximum likelihood functions. — lli","text":"Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17, 368--376.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal maximum likelihood functions. — lli","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of a tree. — as.pml","title":"Likelihood of a tree. — as.pml","text":"pml computes likelihood phylogenetic tree given sequence alignment model. optim.pml optimizes different model parameters.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of a tree. — as.pml","text":"","code":"as.pml(x, ...)  pml(tree, data, bf = NULL, Q = NULL, inv = 0, k = 1, shape = 1,   rate = 1, model = NULL, site.rate = \"gamma\", ...)  optim.pml(object, optNni = FALSE, optBf = FALSE, optQ = FALSE,   optInv = FALSE, optGamma = FALSE, optEdge = TRUE, optRate = FALSE,   optRooted = FALSE, control = pml.control(), model = NULL,   rearrangement = ifelse(optNni, \"NNI\", \"none\"), subs = NULL,   ratchet.par = ratchet.control(), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of a tree. — as.pml","text":"x far object class modelTest. ... arguments passed methods. tree phylogenetic tree, object class phylo. data alignment, object class phyDat. bf Base frequencies (see details). Q vector containing lower triangular part rate matrix. inv Proportion invariable sites. k Number intervals discrete gamma distribution. shape Shape parameter gamma distribution. rate Rate. model allows choose amino acid models nucleotide model, see details. site.rate Indicates type gamma distribution use. Options \"gamma\" approach Yang 1994 (default), \"quadrature\" Laguerre quadrature approach Felsenstein 2001 \"freerate\". object object class pml. optNni Logical value indicating whether topology gets optimized (NNI). optBf Logical value indicating whether base frequencies gets optimized. optQ Logical value indicating whether rate matrix gets optimized. optInv Logical value indicating whether proportion variable size gets optimized. optGamma Logical value indicating whether gamma rate parameter gets optimized. optEdge Logical value indicating edge lengths gets optimized. optRate Logical value indicating overall rate gets optimized. optRooted Logical value indicating edge lengths rooted tree get optimized. control list parameters controlling fitting process. rearrangement type tree tree rearrangements perform, one \"none\", \"NNI\", \"stochastic\" \"ratchet\" subs (integer) vector length Q specify optimization Q ratchet.par search parameter stochastic search","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of a tree. — as.pml","text":"pml optim.pml return list class pml, useful computations like tree phylogenetic tree. data alignment. logLik Log-likelihood tree. siteLik Site log-likelihoods. weight Weight site patterns.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood of a tree. — as.pml","text":"Base frequencies pml can supplied different ways. amino acid usually defined specifying model, argument bf need specified. Otherwise bf=NULL, state given equal probability. can numeric vector given frequencies. Last least bf can string \"equal\", \"empirical\" codon models additionally \"F3x4\". topology search uses nearest neighbor interchange (NNI) implementation similar phyML.  option model pml used amino acid models.  option model defines nucleotide model getting optimized, models included modeltest can chosen. Setting option (e.g. \"K81\" \"GTR\") overrules options optBf optQ.  overview estimate different phylogenetic models pml: Via model optim.pml following nucleotide models can specified: JC, F81, K80, HKY, TrNe, TrN, TPM1, K81, TPM1u, TPM2, TPM2u, TPM3, TPM3u, TIM1e, TIM1, TIM2e, TIM2, TIM3e, TIM3, TVMe, TVM, SYM GTR.  models specified Posada (2008). far 17 amino acid models supported (\"WAG\", \"JTT\", \"LG\", \"Dayhoff\", \"cpREV\", \"mtmam\", \"mtArt\", \"MtZoa\", \"mtREV24\", \"VT\",\"RtREV\", \"HIVw\", \"HIVb\", \"FLU\", \"Blosum62\", \"Dayhoff_DCMut\" \"JTT_DCMut\") additionally rate matrices amino acid frequencies can supplied. also possible estimate codon models (e.g. YN98), details see also chapter vignette(\"phangorn-specials\"). option 'optRooted' set TRUE edge lengths rooted tree optimized. tree rooted now ultrametric! Optimising rooted trees generally much slower. rearrangement set stochastic stochastic search algorithm similar Nguyen et al. (2015). ratchet likelihood ratchet Vos (2003).  helps often find better tree topologies, especially larger trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Likelihood of a tree. — as.pml","text":"Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17, 368--376. Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Yang, Z. (2006). Computational Molecular evolution. Oxford University Press, Oxford. Adachi, J., P. J. Waddell, W. Martin, M. Hasegawa (2000) Plastid genome phylogeny model amino acid substitution proteins encoded chloroplast DNA.  Journal Molecular Evolution, 50, 348--358 Rota-Stabelli, O., Z. Yang, M. Telford. (2009) MtZoa: general mitochondrial amino acid substitutions model animal evolutionary studies. Mol. Phyl. Evol, 52(1), 268--72 Whelan, S. Goldman, N. (2001) general empirical model protein evolution derived multiple protein families using maximum-likelihood approach. Molecular Biology Evolution, 18, 691--699 Le, S.Q. Gascuel, O. (2008) LG: Improved, General Amino-Acid Replacement Matrix Molecular Biology Evolution, 25(7), 1307--1320 Yang, Z., R. Nielsen, M. Hasegawa (1998) Models amino acid substitution applications Mitochondrial protein evolution. Molecular Biology Evolution, 15, 1600--1611 Abascal, F., D. Posada, R. Zardoya (2007) MtArt: new Model amino acid replacement Arthropoda. Molecular Biology Evolution, 24, 1--5 Kosiol, C, Goldman, N (2005) Different versions Dayhoff rate matrix - Molecular Biology Evolution, 22, 193--199 L.-T. Nguyen, H.. Schmidt, . von Haeseler, B.Q. Minh (2015) IQ-TREE: fast effective stochastic algorithm estimating maximum likelihood phylogenies. Molecular Biology Evolution, 32, 268--274. Vos, R. . (2003) Accelerated Likelihood Surface Exploration: Likelihood Ratchet. Systematic Biology, 52(3), 368--373 Yang, Z., R. Nielsen (1998) Synonymous nonsynonymous rate variation nuclear genes mammals. Journal Molecular Evolution, 46, 409-418. Lewis, P.O. (2001) likelihood approach estimating phylogeny discrete morphological character data. Systematic Biology 50, 913--925.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood of a tree. — as.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood of a tree. — as.pml","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  # Jukes-Cantor (starting tree from NJ)   fitJC <- pml(tree, Laurasiatherian) # optimize edge length parameter   fitJC <- optim.pml(fitJC) #> optimize edge weights:  -54808.83 --> -54230.41  #> optimize edge weights:  -54230.41 --> -54230.41  #> optimize edge weights:  -54230.41 --> -54230.41    fitJC #> model: JC  #> loglikelihood: -54230.41  #> unconstrained loglikelihood: -17300.92  #>  #> Rate matrix: #>   a c g t #> a 0 1 1 1 #> c 1 0 1 1 #> g 1 1 0 1 #> t 1 1 1 0 #>  #> Base frequencies:   #>    a    c    g    t  #> 0.25 0.25 0.25 0.25   if (FALSE) { # search for a better tree using NNI rearrangements   fitJC <- optim.pml(fitJC, optNni=TRUE)   fitJC   plot(fitJC$tree)  # JC + Gamma + I - model   fitJC_GI <- update(fitJC, k=4, inv=.2) # optimize shape parameter + proportion of invariant sites   fitJC_GI <- optim.pml(fitJC_GI, optGamma=TRUE, optInv=TRUE) # GTR + Gamma + I - model   fitGTR <- optim.pml(fitJC_GI, rearrangement = \"stochastic\",       optGamma=TRUE, optInv=TRUE, model=\"GTR\") }   # 2-state data (RY-coded)   dat <- acgt2ry(Laurasiatherian)   fit2ST <- pml(tree, dat)   fit2ST <- optim.pml(fit2ST,optNni=TRUE) #> optimize edge weights:  -19996.09 --> -17092.17  #> optimize edge weights:  -17092.17 --> -17092.17  #>  optimize topology:  -17092.17 --> -17058.43  #>  NNI moves:  3  #>  optimize topology:  -17058.43 --> -17030.4  #>  NNI moves:  3  #>  optimize topology:  -17030.4 --> -17025.8  #>  NNI moves:  3  #>  optimize topology:  -17025.8 --> -17024.81  #>  NNI moves:  1  #>  optimize topology:  -17024.81 --> -17024.81  #>  NNI moves:  0  #> NNI moves:  10  #> optimize edge weights:  -17024.81 --> -17024.81  #>  optimize topology:  -17024.81 --> -17024.81  #>  NNI moves:  0  #> NNI moves:  0    fit2ST #> model: Mk  #> loglikelihood: -17024.81  #> unconstrained loglikelihood: -8702.769  #>  #> Rate matrix: #>   r y #> r 0 1 #> y 1 0 #>  #> Base frequencies:   #>   r   y  #> 0.5 0.5  # show some of the methods available for class pml   methods(class=\"pml\") #> [1] AICc   BIC    anova  logLik plot   print  simSeq update vcov   #> see '?methods' for accessing help and source code"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Partitioning — pmlCluster","title":"Stochastic Partitioning — pmlCluster","text":"Stochastic Partitioning genes p cluster.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Partitioning — pmlCluster","text":"","code":"pmlCluster(formula, fit, weight, p = 1:5, part = NULL, nrep = 10,   control = pml.control(epsilon = 1e-08, maxit = 10, trace = 1), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Partitioning — pmlCluster","text":"formula formula object (see details). fit object class pml. weight weight matrix frequency site patterns genes. p number clusters. part starting partition, otherwise random partition generated. nrep number replicates p. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stochastic Partitioning — pmlCluster","text":"pmlCluster returns list elements logLik log-likelihood fit trees list trees optimization. fits fits final partitions","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stochastic Partitioning — pmlCluster","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized cluster, right parameter optimized specific cluster. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameter can used formula.  also restriction combinations parameters can get used. \"rate\" available right side.  \"rate\" specified left hand side \"edge\" specified (either side), \"rate\" specified right hand side follows directly edge .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stochastic Partitioning — pmlCluster","text":"K. P. Schliep (2009). Applications statistical phylogenetics (PhD Thesis) Lanfear, R., Calcott, B., Ho, S.Y.W. Guindon, S. (2012) PartitionFinder: Combined Selection Partitioning Schemes Substitution Models Phylogenetic Analyses. Molecular Biology Evolution, 29(6), 1695-1701","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Stochastic Partitioning — pmlCluster","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stochastic Partitioning — pmlCluster","text":"","code":"if (FALSE) { data(yeast) dm <- dist.logDet(yeast) tree <- NJ(dm) fit <- pml(tree,yeast) fit <- optim.pml(fit)  weight <- xtabs(~ index+genes,attr(yeast, \"index\")) set.seed(1)  sp <- pmlCluster(edge~rate, fit, weight, p=1:4) sp SH.test(sp) }"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":null,"dir":"Reference","previous_headings":"","what":"Phylogenetic mixture model — pmlMix","title":"Phylogenetic mixture model — pmlMix","text":"Phylogenetic mixture model.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phylogenetic mixture model — pmlMix","text":"","code":"pmlMix(formula, fit, m = 2, omega = rep(1/m, m),   control = pml.control(epsilon = 1e-08, maxit = 20, trace = 1), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phylogenetic mixture model — pmlMix","text":"formula formula object (see details). fit object class pml. m number mixtures. omega mixing weights. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phylogenetic mixture model — pmlMix","text":"pmlMix returns list elements logLik log-likelihood fit omega mixing weights. fits fits final mixtures.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phylogenetic mixture model — pmlMix","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized mixtures, right parameter optimized specific mixture. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameters can used formula.  \"rate\" \"nni\" available right side formula. hand parameters invariable sites allowed left-hand side.  convergence algorithm slow likely algorithm can get stuck local optima.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Phylogenetic mixture model — pmlMix","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phylogenetic mixture model — pmlMix","text":"","code":"if (FALSE) { X <- allSitePattern(5) tree <- read.tree(text = \"((t1:0.3,t2:0.3):0.1,(t3:0.3,t4:0.3):0.1,t5:0.5);\") fit <- pml(tree,X, k=4) weights <- 1000*exp(fit$siteLik) attr(X, \"weight\") <- weights fit1 <- update(fit, data=X, k=1) fit2 <- update(fit, data=X)  (fitMixture <- pmlMix(edge~rate, fit1 , m=4)) (fit2 <- optim.pml(fit2, optGamma=TRUE))   data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree <- NJ(dm) fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit)  fit2 <- update(fit, k=4) fit2 <- optim.pml(fit2, optGamma=TRUE)  fitMix <- pmlMix(edge ~ rate, fit, m=4) fitMix   # # simulation of mixture models # X <- allSitePattern(5) tree1 <- read.tree(text = \"((t1:0.1,t2:0.5):0.1,(t3:0.1,t4:0.5):0.1,t5:0.5);\") tree2 <- read.tree(text = \"((t1:0.5,t2:0.1):0.1,(t3:0.5,t4:0.1):0.1,t5:0.5);\") tree1 <- unroot(tree1) tree2 <- unroot(tree2) fit1 <- pml(tree1,X) fit2 <- pml(tree2,X)  weights <- 2000*exp(fit1$siteLik) + 1000*exp(fit2$siteLik) attr(X, \"weight\") <- weights  fit1 <- pml(tree1, X) fit2 <- optim.pml(fit1) logLik(fit2) AIC(fit2, k=log(3000))  fitMixEdge <- pmlMix( ~ edge, fit1, m=2) logLik(fitMixEdge) AIC(fitMixEdge, k=log(3000))  fit.p <- pmlPen(fitMixEdge, .25) logLik(fit.p) AIC(fit.p, k=log(3000)) }"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition model. — multiphyDat2pmlPart","title":"Partition model. — multiphyDat2pmlPart","text":"Model estimate phylogenies partitioned data.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition model. — multiphyDat2pmlPart","text":"","code":"multiphyDat2pmlPart(x, rooted = FALSE, ...)  pmlPart2multiPhylo(x)  pmlPart(formula, object, control = pml.control(epsilon = 1e-08, maxit = 10,   trace = 1), model = NULL, rooted = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition model. — multiphyDat2pmlPart","text":"x object class pmlPart rooted gene trees rooted (ultrametric) unrooted. ... arguments passed methods. formula formula object (see details). object object class pml list objects class pml . control list parameters controlling fitting process. model vector containing models containing model partition.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition model. — multiphyDat2pmlPart","text":"kcluster returns list elements logLik log-likelihood fit trees list trees optimization. object object class \"pml\" \"pmlPart\"","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partition model. — multiphyDat2pmlPart","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized partitions, right parameter optimized specific partition. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameters can used formula.  \"rate\" available right side formula. partitions different edge weights, topology, pmlPen can try find parsimonious models (see example). pmlPart2multiPhylo convenience function extract trees pmlPart object.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Partition model. — multiphyDat2pmlPart","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition model. — multiphyDat2pmlPart","text":"","code":"data(yeast) dm <- dist.logDet(yeast) tree <- NJ(dm) fit <- pml(tree,yeast) fits <- optim.pml(fit) #> optimize edge weights:  -737063 --> -734615.7  #> optimize edge weights:  -734615.7 --> -734615.7  #> optimize edge weights:  -734615.7 --> -734615.7   weight=xtabs(~ index+genes,attr(yeast, \"index\"))[,1:10]  sp <- pmlPart(edge ~ rate + inv, fits, weight=weight) #> loglik: -61530.38 --> -59834.29  #> loglik: -59834.29 --> -59833.25  #> loglik: -59833.25 --> -59833.25  #> loglik: -59833.25 --> -59833.25  sp #>  #> loglikelihood: -59833.25  #>  #> loglikelihood of partitions: #>   -9827.497 -8159.024 -8056.932 -5237.677 -3809.733 -5503.277 -2752.2 -7200.052 -4632.422 -4654.434  #> AIC:  119730.5  BIC:  119963.5  #>  #> Proportion of invariant sites: 0.4000129 0.3179377 0.4746756 0.4490179 0.4122204 0.2912345 0.2419215 0.3097905 0.4794272 0.3884177  #>  #> Rates: #> 1.108058 0.9656371 0.8692633 0.8928421 0.8097406 1.266635 1.296066 1.212794 0.8425937 0.8275096  #>  #> Base frequencies:   #>      [,1] [,2] [,3] [,4] #> [1,] 0.25 0.25 0.25 0.25 #>  #> Rate matrix: #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    1    1    1    1    1  if (FALSE) { sp2 <- pmlPart(~ edge + inv, fits, weight=weight) sp2 AIC(sp2)  sp3 <- pmlPen(sp2, lambda = 2) AIC(sp3) }"},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of a tree. — pml_bb","title":"Likelihood of a tree. — pml_bb","text":"pml_bb pml black box infers phylogentic tree infers tree using maximum likelihood (ML).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of a tree. — pml_bb","text":"","code":"pml_bb(x, model = NULL, rearrangement = \"stochastic\",   method = \"unrooted\", start = NULL, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of a tree. — pml_bb","text":"x alignment class (either class phyDat, DNAbin AAbin) object class modelTest. model string providing model (e.g. \"GTR+G(4)+\"). necessary modelTest object supplied. rearrangement Type tree tree rearrangements perform, one \"none\", \"NNI\", \"stochastic\" \"ratchet\" method One \"unrooted\", \"ultrametric\" \"tiplabeled\". start starting tree can supplied. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of a tree. — pml_bb","text":"pml_bb returns object class pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood of a tree. — pml_bb","text":"pml_bb convenience function combining pml optim.pml. tree supplied, function generate starting tree. modelTest object supplied model chosen according BIC. Currently experimental likely change.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood of a tree. — pml_bb","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood of a tree. — pml_bb","text":"","code":"if (FALSE) { data(woodmouse) tmp <- pml_bb(woodmouse) }"},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Amino Acid Sequences in a File — read.aa","title":"Read Amino Acid Sequences in a File — read.aa","text":"function reads amino acid sequences file, returns matrix list DNA sequences names taxa read file row names.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Amino Acid Sequences in a File — read.aa","text":"","code":"read.aa(file, format = \"interleaved\", skip = 0, nlines = 0,   comment.char = \"#\", seq.names = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read Amino Acid Sequences in a File — read.aa","text":"file file name specified either variable mode character, double-quoted string. format character string specifying format DNA sequences. Three choices possible: \"interleaved\", \"sequential\", \"fasta\", unambiguous abbreviation . skip number lines input file skip beginning read data. nlines number lines read (default file read end). comment.char single character, remaining line character ignored. seq.names names give sequence; default names read file used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Amino Acid Sequences in a File — read.aa","text":"matrix amino acid sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Read Amino Acid Sequences in a File — read.aa","text":"https://en.wikipedia.org/wiki/FASTA_format Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version 3.5c. Department Genetics, University Washington. https://evolution.genetics.washington.edu/phylip/phylip.html","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.aa.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read Amino Acid Sequences in a File — read.aa","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to import and export splits and networks — read.nexus.splits","title":"Function to import and export splits and networks — read.nexus.splits","text":"read.nexus.splits, write.nexus.splits, read.nexus.networx, write.nexus.networx can used import export splits networks nexus format allow exchange object software like SplitsTree. write.splits returns human readable output.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to import and export splits and networks — read.nexus.splits","text":"","code":"read.nexus.splits(file)  write.nexus.splits(obj, file = \"\", weights = NULL, taxa = TRUE,   append = FALSE)  write.nexus.networx(obj, file = \"\", taxa = TRUE, splits = TRUE,   append = FALSE)  read.nexus.networx(file, splits = TRUE)  write.splits(x, file = \"\", zero.print = \".\", one.print = \"|\",   print.labels = TRUE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to import and export splits and networks — read.nexus.splits","text":"file file name. obj object class splits. weights Edge weights. taxa logical. TRUE taxa block added append logical. TRUE nexus blocks added file. splits logical. TRUE nexus blocks added file. x object class splits. zero.print character printed zeros. one.print character printed ones. print.labels logical. TRUE labels printed. ... arguments passed methods. labels names taxa.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to import and export splits and networks — read.nexus.splits","text":"write.nexus.splits write.nexus.networx write splits networx object read software like SplitsTree. read.nexus.splits read.nexus.networx return splits networx object.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Function to import and export splits and networks — read.nexus.splits","text":"read.nexus.splits reads splits block nexus file. assumes different co-variables tab delimited bipartition separated white-space. Comments square brackets ignored.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to import and export splits and networks — read.nexus.splits","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to import and export splits and networks — read.nexus.splits","text":"","code":"(sp <- as.splits(rtree(5))) #>       t4 t5 t1 t3 t2 #>  [1,]  |  .  .  .  . #>  [2,]  .  |  .  .  . #>  [3,]  .  .  |  .  . #>  [4,]  .  .  .  |  . #>  [5,]  .  .  .  .  | #>  [6,]  |  |  |  |  | #>  [7,]  |  |  .  .  . #>  [8,]  .  .  |  |  | #>  [9,]  .  .  .  |  | write.nexus.splits(sp) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.9.0.9000 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=5; #> \tTAXLABELS t4 t5 t1 t3 t2 ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=5 nsplits=8; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.478118034312502 \t1, #> \t\t2\t0.924074469832703 \t1 3 4 5, #> \t\t3\t0.976170694921166 \t1 2 4 5, #> \t\t4\t0.356726912083104 \t1 2 3 5, #> \t\t5\t0.431473690550774 \t1 2 3 4, #> \t\t6\t0.129372348077595 \t1 2, #> \t\t7\t0.59876096714288 \t1 2, #> \t\t8\t0.731792511884123 \t1 2 3, #> \t; #> END; spl <- allCircularSplits(5) plot(as.networx(spl))  write.splits(spl, print.labels = FALSE) #>  #>  #>  |....  #>  #>  .|...  #>  #>  ..|..  #>  #>  ...|.  #>  #>  ....|  #>  #>  ||...  #>  #>  .||..  #>  #>  ..||.  #>  #>  ...||  #>  #>  |...|"},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Import and export sequence alignments — read.phyDat","title":"Import and export sequence alignments — read.phyDat","text":"functions read write sequence alignments.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import and export sequence alignments — read.phyDat","text":"","code":"read.phyDat(file, format = \"phylip\", type = \"DNA\", ...)  write.phyDat(x, file, format = \"phylip\", colsep = \"\", nbcol = -1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import and export sequence alignments — read.phyDat","text":"file file name specified either variable mode character, double-quoted string. format File format sequence alignment (see details).  Several popular formats supported: \"phylip\", \"interleaved\", \"sequential\", \"clustal\", \"fasta\" \"nexus\", unambiguous abbreviation . type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). ... arguments passed methods. x object class phyDat. colsep character used separate columns (single space default). nbcol numeric specifying number columns per row (-1 default); may negative implying nucleotides printed single line.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import and export sequence alignments — read.phyDat","text":"read.phyDat returns object class phyDat, write.phyDat write alignment file.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import and export sequence alignments — read.phyDat","text":"write.phyDat calls function write.dna write.nexus.data read.phyDat calls function read.dna, read.aa read.nexus.data, see details . may import data directly read.dna read.nexus.data convert data class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Import and export sequence alignments — read.phyDat","text":"https://www.ncbi.nlm.nih.gov/blast/fasta.shtml Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version 3.5c. Department Genetics, University Washington. https://evolution.genetics.washington.edu/phylip/phylip.html","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Import and export sequence alignments — read.phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import and export sequence alignments — read.phyDat","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\")"},{"path":"https://klausvigo.github.io/phangorn/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics glance, tidy","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate sequences. — simSeq","title":"Simulate sequences. — simSeq","text":"Simulate sequences given evolutionary tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate sequences. — simSeq","text":"","code":"simSeq(x, ...)  # S3 method for phylo simSeq(x, l = 1000, Q = NULL, bf = NULL,   rootseq = NULL, type = \"DNA\", model = NULL, levels = NULL,   rate = 1, ancestral = FALSE, code = 1, ...)  # S3 method for pml simSeq(x, ancestral = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate sequences. — simSeq","text":"x phylogenetic tree tree, .e. object class phylo object class pml. ... arguments passed methods. l length sequence simulate. Q rate matrix. bf Base frequencies. rootseq vector length l containing root sequence. provided, root sequence randomly generated. type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). model Amino acid model evolution employ, example \"WAG\", \"JTT\", \"Dayhoff\" \"LG\". full list supported models, type phangorn:::.aamodels. Ignored type equal \"AA\". levels character vector different character tokens. Ignored unless type = \"USER\". rate numerical value greater zero giving mutation rate scaler edge lengths. ancestral Logical specifying whether return ancestral sequences. code ncbi genetic code number translation (see details). default standard genetic code used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate sequences. — simSeq","text":"simSeq returns object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate sequences. — simSeq","text":"simSeq generic function simulate sequence alignments along phylogeny. quite flexible can generate DNA, RNA, amino acids, codon, morphological binary sequences. simSeq can take input phylogenetic tree class phylo, pml object; return object class phyDat. also low level version, lacks rate variation, one can combine different alignments rates (see example). rate parameter acts like scaler edge lengths. codon models type=\"CODON\", two additional arguments dnds dN/dS ratio tstv transition transversion ratio can supplied. Defaults: x tree class phylo, sequences generated default Jukes-Cantor DNA model (\"JC\"). bf specified, states treated equally probable. Q specified, uniform rate matrix employed.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate sequences. — simSeq","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate sequences. — simSeq","text":"","code":"if (FALSE) { data(Laurasiatherian) tree <- nj(dist.ml(Laurasiatherian)) fit <- pml(tree, Laurasiatherian, k=4) fit <- optim.pml(fit, optNni=TRUE, model=\"GTR\", optGamma=TRUE) data <- simSeq(fit) }   tree <- rtree(5) plot(tree) nodelabels()   # Example for simple DNA alignment data <- simSeq(tree, l = 10, type=\"DNA\", bf=c(.1,.2,.3,.4), Q=1:6,                ancestral=TRUE) as.character(data) #>    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> t3 \"g\"  \"t\"  \"c\"  \"g\"  \"a\"  \"t\"  \"g\"  \"g\"  \"a\"  \"t\"   #> t4 \"t\"  \"t\"  \"c\"  \"c\"  \"a\"  \"g\"  \"g\"  \"g\"  \"g\"  \"t\"   #> t2 \"g\"  \"g\"  \"c\"  \"g\"  \"a\"  \"c\"  \"t\"  \"g\"  \"g\"  \"t\"   #> t5 \"g\"  \"g\"  \"c\"  \"g\"  \"a\"  \"c\"  \"g\"  \"g\"  \"c\"  \"t\"   #> t1 \"g\"  \"c\"  \"c\"  \"c\"  \"c\"  \"t\"  \"t\"  \"g\"  \"c\"  \"t\"   #> 6  \"g\"  \"t\"  \"t\"  \"g\"  \"a\"  \"g\"  \"g\"  \"g\"  \"a\"  \"g\"   #> 7  \"g\"  \"t\"  \"c\"  \"g\"  \"a\"  \"t\"  \"g\"  \"g\"  \"a\"  \"t\"   #> 8  \"t\"  \"t\"  \"c\"  \"g\"  \"a\"  \"g\"  \"c\"  \"g\"  \"t\"  \"t\"   #> 9  \"g\"  \"g\"  \"c\"  \"g\"  \"a\"  \"c\"  \"g\"  \"g\"  \"c\"  \"t\"     # Example to simulate discrete Gamma rate variation rates <- discrete.gamma(1,4) data1 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[1]) data2 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[2]) data3 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[3]) data4 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[4]) data <- c(data1,data2, data3, data4)  write.phyDat(data, file=\"temp.dat\", format=\"sequential\", nbcol = -1,   colsep = \"\") unlink(\"temp.dat\")"},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Phylogenetic Network — splitsNetwork","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork estimates weights splits graph distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phylogenetic Network — splitsNetwork","text":"","code":"splitsNetwork(dm, splits = NULL, gamma = 0.1, lambda = 1e-06,   weight = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phylogenetic Network — splitsNetwork","text":"dm distance matrix. splits splits object, containing splits consider, otherwise possible splits used gamma penalty value L1 constraint. lambda penalty value L2 constraint. weight vector weights.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork returns splits object matrix added. first column contains indices splits, second column unconstrained fit without penalty terms third column constrained fit.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork fits non-negative least-squares phylogenetic networks using L1 (LASSO), L2(ridge regression) constraints.  function minimizes penalized least squares $$\\beta = min \\sum(dm - X\\beta)^2 + \\lambda \\|\\beta \\|^2_2 $$ respect $$\\|\\beta \\|_1 <= \\gamma, \\beta >= 0$$ \\(X\\) design matrix constructed designSplits. External edges fitted without L1 L2 constraints.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Phylogenetic Network — splitsNetwork","text":"Efron, Hastie, Johnstone Tibshirani (2004) Least Angle Regression (discussion) Annals Statistics 32(2), 407--499 K. P. Schliep (2009). Applications statistical phylogenetics (PhD Thesis)","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Phylogenetic Network — splitsNetwork","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phylogenetic Network — splitsNetwork","text":"","code":"data(yeast) dm <- dist.ml(yeast) fit <- splitsNetwork(dm) net <- as.networx(fit) plot(net)  write.nexus.splits(fit) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.9.0.9000 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=8; #> \tTAXLABELS Scer Spar Smik Skud Sbay Scas Sklu Calb ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=8 nsplits=11; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.0651863267300081 \t1, #> \t\t2\t0.0587181431952474 \t1 3 4 5 6 7 8, #> \t\t3\t0.0696966249845726 \t1 2 4 5 6 7 8, #> \t\t4\t0.00922628123679264 \t1 2 3, #> \t\t5\t0.0814873449151825 \t1 2 3 5 6 7 8, #> \t\t6\t0.00406555188582689 \t1 2 3 4, #> \t\t7\t0.088677881565572 \t1 2 3 4 6 7 8, #> \t\t8\t0.0867081912739521 \t1 2 3 4 5, #> \t\t9\t0.176465217267573 \t1 2 3 4 5 7 8, #> \t\t10\t0.20830599608214 \t1 2 3 4 5 6 8, #> \t\t11\t0.364797554608849 \t1 2 3 4 5 6 7, #> \t; #> END;"},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Super Tree methods — superTree","title":"Super Tree methods — superTree","text":"function superTree allows estimation supertree set trees using either Matrix representation parsimony, Robinson-Foulds SPR criterion.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Super Tree methods — superTree","text":"","code":"superTree(tree, method = \"MRP\", rooted = FALSE, trace = 0,   start = NULL, multicore = FALSE, mc.cores = NULL, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Super Tree methods — superTree","text":"tree object class multiPhylo method argument defining algorithm used optimize tree.  Possible \"MRP\", \"RF\", \"SPR\". rooted resulting supertrees rooted. trace defines much information printed optimization. start starting tree can supplied. multicore logical, whether models estimated parallel. mc.cores number cores use, .e. many child processes run simultaneously. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Super Tree methods — superTree","text":"function returns object class phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Super Tree methods — superTree","text":"function superTree extends function mrp.supertree Liam Revells, artificial adding outgroup root trees.  allows root supertree afterwards. functions internally used DensiTree. implementation RF- SPR-supertree basic far assume trees share set taxa.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Super Tree methods — superTree","text":"Baum, B. R., (1992) Combining trees way combining data sets phylogenetic inference, desirability combining gene trees. Taxon, 41, 3-10. Ragan, M. . (1992) Phylogenetic inference based matrix representation trees. Molecular Phylogenetics Evolution, 1, 53-58.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Super Tree methods — superTree","text":"Klaus Schliep klaus.schliep@gmail.com Liam Revell","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Super Tree methods — superTree","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian,                        FUN = function(x) upgma(dist.hamming(x)), bs=50)  mrp_st <- superTree(bs) plot(mrp_st)     if (FALSE) { rf_st <- superTree(bs, method = \"RF\") spr_st <- superTree(bs, method = \"SPR\") }"},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances between trees — treedist","title":"Distances between trees — treedist","text":"treedist computes different tree distance methods RF.dist Robinson-Foulds symmetric distance. Robinson-Foulds distance depends topology trees. edge weights considered wRF.dist calculates weighted RF distance (Robinson & Foulds 1981). KF.dist calculates branch score distance (Kuhner & Felsenstein 1994).  path.dist computes path difference metric described Steel Penny 1993). sprdist computes approximate SPR distance (Oliveira Martins et al. 2008, de Oliveira Martins 2016).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distances between trees — treedist","text":"","code":"treedist(tree1, tree2, check.labels = TRUE)  sprdist(tree1, tree2)  SPR.dist(tree1, tree2 = NULL)  RF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,   rooted = FALSE)  wRF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,   rooted = FALSE)  KF.dist(tree1, tree2 = NULL, check.labels = TRUE, rooted = FALSE)  path.dist(tree1, tree2 = NULL, check.labels = TRUE, use.weight = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distances between trees — treedist","text":"tree1 phylogenetic tree (class phylo) vector trees (object class multiPhylo). See details tree2 phylogenetic tree. check.labels compares labels trees. normalize compute normalized RF-distance, see details. rooted take bipartitions rooted trees account, default unrooting trees. use.weight use edge.length argument just count number edges path (default)","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distances between trees — treedist","text":"treedist returns vector containing following tree distance methods symmetric.difference symmetric.difference Robinson-Foulds distance branch.score.difference branch.score.difference path.difference path.difference weighted.path.difference weighted.path.difference","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distances between trees — treedist","text":"Robinson-Foulds distance two trees \\(T_1\\) \\(T_2\\) \\(n\\) tips defined (following notation Steel Penny 1993): $$d(T_1, T_2) = (T_1) + (T_2) - 2v_s(T_1, T_2)$$ \\((T_1)\\) denotes number internal edges \\(v_s(T_1, T_2)\\) denotes number internal splits shared two trees. normalized Robinson-Foulds distance derived dividing \\(d(T_1, T_2)\\) maximal possible distance \\((T_1) + (T_2)\\). trees unrooted binary value \\(2n-6\\). Functions like RF.dist returns Robinson-Foulds distance (Robinson Foulds 1981) either 2 trees computes matrix pairwise distances multiPhylo object given. large number trees distance functions can use lot memory!","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distances between trees — treedist","text":"de Oliveira Martins L., Leal E., Kishino H. (2008) Phylogenetic Detection Recombination Bayesian Prior Distance Trees. PLoS ONE 3(7). e2651. doi: 10.1371/journal.pone.0002651 de Oliveira Martins L., Mallo D., Posada D. (2016) Bayesian Supertree Model Genome-Wide Species Tree Reconstruction. Syst. Biol. 65(3): 397-416, doi:10.1093/sysbio/syu082 Steel M. . Penny P. (1993) Distributions tree comparison metrics - new results, Syst. Biol., 42(2), 126--141 Kuhner, M. K. Felsenstein, J. (1994) simulation comparison phylogeny algorithms equal unequal evolutionary rates, Molecular Biology Evolution, 11(3), 459--468 D.F. Robinson L.R. Foulds (1981) Comparison phylogenetic trees, Mathematical Biosciences, 53(1), 131--147 D.F. Robinson L.R. Foulds (1979) Comparison weighted labelled trees. Horadam, . F. Wallis, W. D. (Eds.), Combinatorial Mathematics VI: Proceedings Sixth Australian Conference Combinatorial Mathematics, Armidale, Australia, 119--126","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distances between trees — treedist","text":"Klaus P. Schliep klaus.schliep@gmail.com, Leonardo de Oliveira Martins","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distances between trees — treedist","text":"","code":"tree1 <- rtree(100, rooted=FALSE) tree2 <- rSPR(tree1, 3) RF.dist(tree1, tree2) #> [1] 36 treedist(tree1, tree2) #>      symmetric.difference   branch.score.difference           path.difference  #>                 36.000000                  2.926122                133.082681  #> quadratic.path.difference  #>                 66.523380  sprdist(tree1, tree2) #>       spr spr_extra        rf     hdist  #>         3         0        36        30  trees <- rSPR(tree1, 1:5) SPR.dist(tree1, trees) #> [1] 1 2 3 4 4"},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":null,"dir":"Reference","previous_headings":"","what":"UPGMA and WPGMA — upgma","title":"UPGMA and WPGMA — upgma","text":"UPGMA WPGMA clustering. Just wrapper function around hclust.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UPGMA and WPGMA — upgma","text":"","code":"upgma(D, method = \"average\", ...)  wpgma(D, method = \"mcquitty\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UPGMA and WPGMA — upgma","text":"D distance matrix. method agglomeration method used. (unambiguous abbreviation ) one \"ward\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\" \"centroid\". default \"average\". ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"UPGMA and WPGMA — upgma","text":"phylogenetic tree class phylo.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"UPGMA and WPGMA — upgma","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"UPGMA and WPGMA — upgma","text":"","code":"data(Laurasiatherian) dm <- dist.ml(Laurasiatherian) tree <- upgma(dm) plot(tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Writing and reading distances in phylip and nexus format — writeDist","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"readDist, writeDist write.nexus.dist useful exchange distance matrices phylogenetic programs.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"","code":"writeDist(x, file = \"\", format = \"phylip\", ...)  write.nexus.dist(x, file = \"\", append = FALSE, upper = FALSE,   diag = TRUE, digits = getOption(\"digits\"), taxa = !append)  readDist(file, format = \"phylip\")  read.nexus.dist(file)  # S3 method for dist unique(x, incomparables, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"x dist object. file file name. format file format, default \"phylip\", option far \"nexus\". ... arguments passed methods. append logical. TRUE nexus blocks added file. upper logical value indicating whether upper triangle distance matrix printed. diag logical value indicating whether diagonal distance matrix printed. digits passed format inside write.nexus.dist. taxa logical. TRUE taxa block added. incomparables used far.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"object class dist","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"Maddison, D. R., Swofford, D. L. Maddison, W. P. (1997) NEXUS: extensible file format systematic information. Systematic Biology, 46, 590--621.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"","code":"data(yeast) dm <- dist.ml(yeast) writeDist(dm) #> 8  #> Scer 0 0.0867845773228216 0.137636794490987 0.161087155144511 0.177174556271658 0.345373797843901 0.381679949757669 0.537234265198944 #> Spar 0.0867845773228216 0 0.123600617669833 0.149284159950583 0.166375240744154 0.343965239042024 0.380724585630441 0.53742766184754 #> Smik 0.137636794490987 0.123600617669833 0 0.155370638334037 0.173395434179653 0.345111830071115 0.381038543686742 0.5378791145715 #> Skud 0.161087155144511 0.149284159950583 0.155370638334037 0 0.156795687960896 0.351411419602885 0.383976534826636 0.548399134277832 #> Sbay 0.177174556271658 0.166375240744154 0.173395434179653 0.156795687960896 0 0.345921564868849 0.380960041850599 0.54884540980469 #> Scas 0.345373797843901 0.343965239042024 0.345111830071115 0.351411419602885 0.345921564868849 0 0.390140463219943 0.527683919271109 #> Sklu 0.381679949757669 0.380724585630441 0.381038543686742 0.383976534826636 0.380960041850599 0.390140463219943 0 0.542132862145574 #> Calb 0.537234265198944 0.53742766184754 0.5378791145715 0.548399134277832 0.54884540980469 0.527683919271109 0.542132862145574 0 write.nexus.dist(dm) #> #NEXUS #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=8; #> \tTAXLABELS Scer Spar Smik Skud Sbay Scas Sklu Calb ; #> END; #>  #> BEGIN DISTANCES;  #> \tFORMAT TRIANGLE = LOWER; #> \tMatrix  #> \tScer 0.00000000 #> \tSpar 0.08678458 0.00000000 #> \tSmik 0.13763679 0.12360062 0.00000000 #> \tSkud 0.16108716 0.14928416 0.15537064 0.00000000 #> \tSbay 0.17717456 0.16637524 0.17339543 0.15679569 0.00000000 #> \tScas 0.34537380 0.34396524 0.34511183 0.35141142 0.34592156 0.00000000 #> \tSklu 0.38167995 0.38072459 0.38103854 0.38397653 0.38096004 0.39014046 0.00000000 #> \tCalb 0.53723427 0.53742766 0.53787911 0.54839913 0.54884541 0.52768392 0.54213286 0.00000000 #> \t; #> END;"},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":null,"dir":"Reference","previous_headings":"","what":"Yeast alignment (Rokas et al.) — yeast","title":"Yeast alignment (Rokas et al.) — yeast","text":"Alignment 106 genes 8 different species yeast.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Yeast alignment (Rokas et al.) — yeast","text":"Rokas, ., Williams, B. L., King, N., Carroll, S. B. (2003) Genome-scale approaches resolving incongruence molecular phylogenies. Nature, 425(6960): 798--804","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Yeast alignment (Rokas et al.) — yeast","text":"","code":"data(yeast) str(yeast) #> List of 8 #>  $ Scer: int [1:8899] 4 2 4 4 1 4 3 1 3 3 ... #>  $ Spar: int [1:8899] 4 2 4 4 3 4 1 1 3 3 ... #>  $ Smik: int [1:8899] 4 2 2 4 3 2 1 1 1 3 ... #>  $ Skud: int [1:8899] 4 2 4 4 3 2 1 1 3 3 ... #>  $ Sbay: int [1:8899] 4 2 4 4 1 2 1 1 3 3 ... #>  $ Scas: int [1:8899] 4 2 1 2 1 4 1 1 1 3 ... #>  $ Sklu: int [1:8899] 4 2 4 2 4 2 1 1 3 3 ... #>  $ Calb: int [1:8899] 4 2 4 2 4 4 3 1 1 3 ... #>  - attr(*, \"class\")= chr \"phyDat\" #>  - attr(*, \"weight\")= int [1:8899] 16974 7986 25 132 1 78 29 17646 42 12618 ... #>  - attr(*, \"nr\")= int 8899 #>  - attr(*, \"nc\")= num 4 #>  - attr(*, \"index\")='data.frame':\t127026 obs. of  2 variables: #>   ..$ index: int [1:127026] 1 2 3 4 1 5 6 1 7 8 ... #>   ..$ genes: Factor w/ 106 levels \"YAL053W\",\"YAR007C\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"levels\")= chr [1:4] \"a\" \"c\" \"g\" \"t\" #>  - attr(*, \"allLevels\")= chr [1:18] \"a\" \"c\" \"g\" \"t\" ... #>  - attr(*, \"type\")= chr \"DNA\" #>  - attr(*, \"contrast\")= num [1:18, 1:4] 1 0 0 0 0 1 1 1 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:4] \"a\" \"c\" \"g\" \"t\""}]
