---
title: 'Intertwining phylogenetic trees and networks: R Example Script'
author: "Klaus Schliep, Alastair Potts, David Morrison and Guido Grimm"
date: "`r format(Sys.time(), '%B %d, %Y')`"
bibliography: phangorn.bib
output: rmarkdown::html_vignette
vignette: >
   %\VignetteIndexEntry{IntertwiningTreesAndNetworks}
   %\VignetteEngine{knitr::rmarkdown}
   %\usepackage[utf8]{inputenc}
---
output: rmarkdown::html_vignette

```{r setup, echo=FALSE}
# set global chunk options: images will be bigger
knitr::opts_chunk$set(fig.width=7, fig.height=7) 
options(digits = 4)
```


*Description:* This script provides examples of the new functions available in the phangorn library to 'intertwine' trees and networks, i.e. compare trees and networks and data transferrance. It also provides a step-by-step guide for users new to R. 

*Methodological advancement:* The major advancement in this phangorn update is the introduction of a generic network object with a wide range of related transfer and analysis functions. These new functions provide the first means to directly transfer information amongst a wide range of phylogenetic trees and networks, as well as means to visualise and further analyse this information. This should provide a platform for individuals to easily conduct tree-network comparisons and stimulate further function development by the community.

*What next?:* By implementing full network handling compatibility in R, and providing exemplar scripts (such as this) and [support](https://github.com/KlausVigo/phangorn), the scientific community now has an easy means to analyse and compare the results of phylogenetic trees vs. network approaches. We hope this will open a largely unexplored world to the general phylogenetic audience. 


### Installing R                                                 
1. Download R                                                     
 Select the nearest mirror to your location at https://cran.r-project.org/mirrors.html                          
2. Select your operating system and download the relevant installation file.                                             
3. Install R following the instructions.                          

### Installing the phangorn library                                 
Open R and run the two lines of code below in the command line.   
(You will need to select a region from which to download the library)                       
```{r, eval=FALSE}
install.packages("phangorn", dependencies=TRUE)
# install latest development version needs devtools
install.packages("devtools", dependencies=TRUE)
library(devtools)
install_github("KlausVigo/phangorn")
```


### Getting started                                                  
```{r}
library(phangorn)    # load the phangorn library
```

### Set the working directory
This is often a major stumbling block for new R users. You need to specify where in your folder structure you wish to work. i.e, where are the files stored that you wish to input?

This is done using the setwd() function, e.g. setwd("C:/TreesNetworks/Example Files").

We now set it to the folder of the phangorn package, which contains the files we want to load for this example.

### Read in the example file datasets:
This example files are based on the woodmouse dataset available in the ape library. Ultimately, this dataset is from this study: Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. and Libois, R. (2003) 
Mitochondrial phylogeography of the Woodmouse (*Apodemus sylvaticus*) in the Western 
Palearctic region. Molecular Ecology, 12, 685-697.)
 
```{r} 
## automatically set the correct working directory for the examples below
# setwd(system.file("extdata/trees", package = "phangorn"))
# for this vignette we create a path to the files we want to load 
fdir <- system.file("extdata/trees", package = "phangorn")
## in your case it may look something like this...
# setwd("C:/TreesNetworks/Example Files")

##DNA Matrix, maybe not needed 
woodmouse <- read.phyDat(file.path(fdir, "woodmouse.fasta"),format="fasta") 
## RAxML best-known tree with bipartition support (from previous analysis)
raxml.tree <- read.tree(file.path(fdir,"RAxML_bipartitions.woodmouse"))
## RAxML bootstrap trees (from previous analysis)
raxml.bootstrap <- read.tree(file.path(fdir,"RAxML_bootstrap.woodmouse"))
## MrBayes consensus tree (50% majority rule) (from previous analysis)
mrbayes.tree <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.con"))
## MrBayes sample runs 1 and 2 (from previous analysis)
run1 <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.run1.t"))
run2 <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.run2.t"))
## How many trees are in the MrBayes tree sample?
run1
run2
## Combining the two runs and removing 25% burn-in
mrbayes.trees <- c(run1[251:1001],run2[251:1001])
## NeigbourNet Nexus file generated by SplitsTree (from previous analysis)
Nnet <- read.nexus.networx(file.path(fdir,"woodmouse.nxs"))
```
All example files read into R.

### Viewing the data   
```{r}
par(mfrow=c(1,2), mar=c(2,2,2,2)) # Setting plot parameters
### Plotting trees with support values:
##  RAxML
plot(raxml.tree)
nodelabels(raxml.tree$node.label, adj = c(1, 0), frame = "none")
##  MrBayes
plot(mrbayes.tree)
nodelabels(mrbayes.tree$node.label, adj = c(1, 0), frame = "none")

par(mfrow=c(1,1)) # Setting plot parameters
# NeighbourNet
plot(Nnet,"2D")
## alternatively,
# plot(Nnet,"2D")

```

### Interwining trees and network functions                         
### 1A: 
Identification of edge bundles (in black) in a neighbour-net (NN) network that correspond to branches (labelled 1-12) in a tree (a maximum likelihood tree, in this case). 

```{r} 
# create a vector of labels for the network corresponding to edges in the tree
edge.lab <- createLabel(Nnet, raxml.tree, raxml.tree$edge[,2], "edge")
# could be also 1:27 instead of raxml.tree$edge[,2]

# Show the correspondingly labelled tree and network in R
par(mfrow=c(1,2), mar=c(1,1,1,1))
#plotBS(raxml.tree, rotate.tree = 180) 
plot(raxml.tree, "u", rotate.tree = 180) 
edgelabels(raxml.tree$edge[,2],col="blue", frame="none")

# find edges that are in the network but not in the tree
edge.col <- rep("black", nrow(Nnet$edge))
edge.col[ is.na(edge.lab) ] <- "red"
# or a simpler alternative...
edge.col <- createLabel(Nnet, raxml.tree, "black", nomatch="red")

x <- plot(Nnet, edge.label = edge.lab, show.edge.label = T, "2D", edge.color = edge.col,
                  col.edge.label = "blue")
# the above plot function returns an invisible networx object and this object also  
# contains the colors for the edges.

```


### 1B: 
Bootstrap support for all branches (branch labels) in the ML tree mapped on the corresponding edge bundles of the NN network. The edges in the network which are not found as ML tree branches are highlighted in red.
```{r}   
x <- addConfidences(Nnet,raxml.tree)
# find splits that are in the network but not in the tree
split.col <- rep("black", length(x$splits))
split.col[ !matchSplits(as.splits(x), as.splits(raxml.tree)) ] <- "red"

# simpler alternative...
split.col2 <- createLabel(x, raxml.tree, label="black", "split", nomatch="red")

# Plotting in R
par(mfrow=c(1,1))
out.x <- plot(x,"2D",show.edge.label=TRUE, split.color=split.col, col.edge.label = "blue")
```
Again we can write to SplitsTree for viewing...
```{r}
# write.nexus.networx(out.x,"woodmouse.tree.support.nxs")
## or we can also export the splits alone (for usage in software other than SplitsTree)
# write.nexus.splits(as.splits(out.x),"woodmouse.splits.support.nxs")
```

### 1C: 
Frequencies of bipartitions found in the bootstrap pseudoreplicates mapped on the corresponding edge bundles of the NN network using a threshold of 10% (i.e. any edge is labelled that occurs in at least 
100 of the 1000 ML-BS pseudoreplicates). Edge bundles not found in the ML tree are labelled using grey edges.

```{r}
y <- addConfidences(Nnet, as.splits(raxml.bootstrap))
edge.col <- createLabel(y, raxml.tree, label="black", "edge", nomatch="grey")

y <- plot(y,"2D",show.edge.label=TRUE, edge.color=edge.col)

## Write to SplitsTree for viewing
# write.nexus.networx(y,"NN.with.bs.support.nxs")
```

### Extras...
We can also compare the neighborNet with a consensusNet (Holland BR, Huber KT, Moulton V, Lockhart PJ,2004, Using consensus networks to visualize contradictory evidence for species phylogeny. Molecular Biology and Evolution, 21, 1459-1461). Furthermore, we can extract the support values from the consensus network, and place these on to the NeighbourNet (this is similar to the process explained in 1C above).
```{r}
cnet <- consensusNet(raxml.bootstrap,prob=0.10)
edge.col <- createLabel(cnet, Nnet, label="black", "edge", nomatch="grey")
cnet <- plot(cnet, "2D", show.edge.label = TRUE, edge.color=edge.col)

edge.col <- createLabel(Nnet, cnet, label="black", "edge", nomatch="grey")
z <- plot(Nnet, "2D", show.edge.label = TRUE, edge.color=edge.col)

obj <- addConfidences(Nnet,cnet)
plot(obj,"2D",show.edge.label=T, edge.color=edge.col, col.edge.label = "blue")

## Write to SplitsTree for viewing
# write.nexus.networx(obj,"Nnet.with.ML.Cnet.Bootstrap.nxs")
```


### 

Next we show relationship between splits weights, from a NeighborNet splits graph, and the bootstrap percentage. 

```{r, fig.width=7, fig.height=6} 
bs_splits <- as.splits(raxml.bootstrap)
# we get rid of a trivial splits
bs_splits <- bs_splits[-which(lengths(bs_splits)==15)]
net_weights <- attr(Nnet$splits, "weights")

# some
splits_in_BS <- matchSplits(Nnet$splits, bs_splits, FALSE)
in_BS <- which(!is.na(splits_in_BS))

#Next we construct a table with two columns, the first one holding the edge weights (or 1e-6) and the second one the bootstrap support.  
tab <- cbind(SplitWeight = 1e-6, Bootstrap=attr(bs_splits, "weights"))
tab[splits_in_BS[in_BS], "SplitWeight"] <- net_weights[in_BS]
tab <- rbind(tab, cbind(net_weights[-in_BS], 0))
tab[,"Bootstrap"] <- tab[,"Bootstrap"] / 10
summary(tab)

col = rep("blue", nrow(tab))
col[tab[,1]==1e-6] <- "green"
col[tab[,2]==0] <- "red"

plot(tab[,"SplitWeight"], tab[,"Bootstrap"], log="x", col=col, pch=20,  
     xlab="Split weight (log scale)", ylab="Bootstrap (%)")
legend(2e-6, 100, c("Splits supported by bootstrap analysis \nbut not shown in the splits graph\n", "Splits supported by the bootstrap analysis \nand appear in the splits graph\n", "Well-supported splits \nbut no bootstrap support\n"), pch=20, col=c("green", "blue", "red"), bty="n")
```

### PLot 3

```{r} 
library(magrittr)
YCh <- read.tree(file.path(fdir, "RAxML_bestTree.YCh")) 
mtG <- read.tree(file.path(fdir, "RAxML_bestTree.mtG")) 
ncAI <- read.tree(file.path(fdir, "RAxML_bestTree.AIs")) 
all_data <- read.tree(file.path(fdir, "RAxML_bestTree.3moles")) 
YCh_boot <- read.tree(file.path(fdir, "RAxML_bootstrap.YCh")) 
mtG_boot <- read.tree(file.path(fdir, "RAxML_bootstrap.mtG")) 
ncAI_boot <- read.tree(file.path(fdir, "RAxML_bootstrap.AIs")) 
all_data_boot <- read.tree(file.path(fdir, "RAxML_bootstrap.3moles")) 
```

There are several option plotting a co-phylogeny. In the following we use the 
`cophylo` function of the `phytools` package. 

[comment]: # ({r cophylo, fig.width=7, fig.height=7})

```
library(phytools)
par(mfrow=c(2,1))
obj <- cophylo(YCh, mtG) 
plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1))  
title("A. YCh                                    B. mtG")
obj <-  cophylo(ncAI, all_data)
plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1))
title("C. ncAI                              D. All data")
```
![](cophylo.png)

```{r}
par(mfrow=c(2,2))
YCh <- plotBS(midpoint(YCh), YCh_boot, "phylogram", p=0)
mtG <- plotBS(midpoint(mtG), mtG_boot, "phylogram", p=0)
ncAI <- plotBS(midpoint(ncAI), ncAI_boot, "phylogram", p=0)
all_data <- plotBS(midpoint(all_data), all_data_boot, "phylogram", p=0)
```

```{r}
par(mfrow=c(1,1), mar=c(3,3,3,3))
cn <- consensusNet(c(YCh, mtG, ncAI))
cn <- addConfidences(cn, YCh_boot) %>% addConfidences(mtG_boot, add=TRUE) %>% addConfidences(ncAI_boot, add=TRUE) %>% addConfidences(all_data_boot, add=TRUE)
plot(cn, "2D", show.edge.label=TRUE)
```

